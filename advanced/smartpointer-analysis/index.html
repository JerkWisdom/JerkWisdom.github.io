<!DOCTYPE html>
<html>

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>智能指针二三事 | 小熊糖否——木子兮的自留地</title>
  <meta name="description" content="智能指针是资源管理的必备神器，掌握智能指针，开发稳定可靠的应用程序。">
<meta property="og:type" content="article">
<meta property="og:title" content="智能指针二三事">
<meta property="og:url" content="https://www.freehacker.cn/advanced/smartpointer-analysis/index.html">
<meta property="og:site_name" content="小熊糖否——木子兮的自留地">
<meta property="og:description" content="智能指针是资源管理的必备神器，掌握智能指针，开发稳定可靠的应用程序。">
<meta property="og:locale">
<meta property="article:published_time" content="2018-10-13T00:48:41.000Z">
<meta property="article:modified_time" content="2020-10-27T04:47:05.346Z">
<meta property="article:author" content="ZeroJiu">
<meta property="article:tag" content="CPlusPlus">
<meta property="article:tag" content="Experience">
<meta name="twitter:card" content="summary">
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="/favicon.ico">

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css">

  <meta name="generator" content="小熊糖否——木子兮的自留地">


  
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  

  <!--载入js，在</body>之前插入即可-->
  <!--Leancloud 操作库:-->
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <!--Valine 的核心代码库-->
  <script src="../../source/js/Valine.min.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body class="post-template nav-closed ">

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
            <li class="nav-home nav-current" role="presentation"><a href="/">Home</a></li>
			<li class="nav-developing" role="presentation"><a href="/categories/Developing">Developing</a></li>
            <li class="nav-reading" role="presentation"><a href="/categories/Reading">Reading</a></li>
			<li class="nav-utility" role="presentation"><a href="/categories/Utility">Utility</a></li>
			<li class="nav-timecapsule" role="presentation"><a href="/categories/TimeCapsule">TimeCapsule</a></li>
            <li class="nav-wikipedia" role="presentation"><a target="_blank" rel="noopener" href="https://wikipedia.freehacker.cn">Wikipedia</a></li>
			<li class="nav-search" role="presentation"><a href="/search/">Search</a></li>
			<li class="nav-about" role="presentation"><a href="/about/">About</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/atom.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

  <div class="site-wrapper">
	


	<header class="main-header post-head" style="background-image: url(http://ww4.sinaimg.cn/large/61b57e82gw1f8obk6993nj21gs0i240q.jpg)">
		<nav class="main-nav overlay clearfix">
			<a class="blog-logo" href="/"><img src="http://ww3.sinaimg.cn/large/61b57e82gw1f9hqu7hp7kj2068020wea.jpg" alt="Blog Logo"/></a>
			<a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
		</nav>
		<div class="vertical">
			<div class="main-header-content inner">
				<a class="page-title"></a>
				<a class="page-description"> </a>
			</div>
		</div>
	</header>
	

	<main class="content" role="main">
	  <article class="post">
		  <header class="post-header">
			<h1 class="post-title">智能指针二三事</h1>
			<footer class="post-meta">
	<img class="author-thumb" src="http://ww1.sinaimg.cn/large/61b57e82gw1f1v79yu8v1j20hs0kwdht.jpg" alt="ZeroJiu" />
    <a href="/about">ZeroJiu</a>
	
    On
    
	
    <a href='/tags/CPlusPlus/'>CPlusPlus</a> /
    
    <a href='/tags/Experience/'>Experience</a>
    
    
    At
    <time class="post-date" datetime="2018-10-13T00:48:41.000Z" >
          2018-10-13
    </time>
</footer>

		  </header>
          

		  <section class="post-content">
			<blockquote><p>韭菜的自我修养。</p>
<footer><strong>李笑来</strong></footer></blockquote>
<p>C++11中引入智能指针，智能指针主要用来解决资源管理中遇到的各种问题。在引入智能指针之前，我们必须要操作裸指针，裸指针是导致内存问题的罪魁祸首——空悬指针、内存泄漏、分配失败等。一些著名的开源C项目，现在仍然还需要面临着一些由裸指针引起的内存问题。<a id="more"></a></p>
<p>如何使用智能指针能够轻易地在C++11标准中找到，如何用好智能指针却并不是那么简单。我们必须要清楚：</p>
<ul>
<li>智能指针解决了哪些问题？</li>
<li>智能指针引入了哪些问题？</li>
<li>智能指针使用存在哪些坑？</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>C++11标准库中，智能指针主要包含<em>unique_ptr</em>、<em>shared_ptr</em>、<em>weak_ptr</em>三种。这三种智能指针已经能够解决我们遇到的大多数问题。这些问题包含：</p>
<ul>
<li>内存泄漏</li>
<li>指针有效性检测</li>
<li>资源独占</li>
<li>多线程资源管理</li>
<li>跨dll资源管理</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>智能指针能够实现自动垃圾回收（Automatic Garbage Collection），这有效的解决了程序中部分内存/资源泄漏问题。智能指针能够有效地防止由于程序<strong>异常</strong>而导致的资源泄漏。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object* p = <span class="keyword">new</span> Object();</span><br><span class="line">    p-&gt;doSomething(); <span class="comment">/* throw exception */</span></span><br><span class="line">    <span class="keyword">delete</span> p;         <span class="comment">/* memory leak and resource leak in Object */</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    p-&gt;doSomething(); <span class="comment">/* throw exception */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针有效性检测"><a href="#指针有效性检测" class="headerlink" title="指针有效性检测"></a>指针有效性检测</h3><p>裸指针只能检测指针是否是nullptr，无法检测出指针指向的对象是否有效。而智能指针能够检测其所指向对象的有效性。</p>
<p>裸指针若不初始化，其值是一个随机值，也就是野指针，而智能指针会默认初始化为nullptr。编译器一般会对<strong>使用未初始化的野指针</strong>报错，若不报错我们则会面临程序奔溃、内存越界的风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p;   <span class="comment">/* p为野指针 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* pp; <span class="comment">/* pp非野指针 */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">char</span>&gt; sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>裸指针指向的对象被销毁后，未将裸指针设置为nullptr，则裸指针称为空悬指针。出现空悬指针的情况如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    p = &amp;c;</span><br><span class="line">  &#125; <span class="comment">/* c释放，p为空悬指针 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">/* p为空悬指针 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;num; <span class="comment">/* 返回一个空悬指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问空悬指针程序会抛出异常<em>write access violation</em>。而对智能指针，只有指针生命期结束或主动指向其他对象时，其所指向的对象才会被销毁（引用计数减一）。故而，智能指针不存在空悬指针问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>); <span class="comment">/* 对象释放后又重新构造一个对象，sp1可以继续使用 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);  </span><br><span class="line">  &#125; <span class="comment">/* 对象释放，但也无法使用sp2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源独占"><a href="#资源独占" class="headerlink" title="资源独占"></a>资源独占</h3><p>裸指针无法保证资源独占，可能会存在多个指针指向同一个对象，进而导致一些难以控制的问题。譬如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object *p1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object *p2 = p1;</span><br><span class="line">  <span class="keyword">delete</span> p1;</span><br><span class="line">  *p2; <span class="comment">/* 空悬指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针中的<em>std::unique_ptr</em>能够独占资源所有权，某时某刻只有一个<em>std::unique_ptr</em>指向特定的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> Object())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up2 = up1; <span class="comment">/* error */</span></span><br><span class="line">  up2 = <span class="built_in">std</span>::move(up1); <span class="comment">/* up1转移所有权给up2，up1为nullptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程资源管理"><a href="#多线程资源管理" class="headerlink" title="多线程资源管理"></a>多线程资源管理</h3><p>智能指针能够很好地解决多线程情况下对象析构问题。这是裸指针难以办到的。对于裸指针来说，如果一个线程要访问该指针，而另一个线程需要delete该指针，后果难以想象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~T() &#123; <span class="comment">/* destruct resource in mutex */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">/* update resource in mutex*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> T *t;</span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">t = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line"><span class="keyword">if</span> (t) t-&gt;update();</span><br></pre></td></tr></table></figure>
<p>即使有锁的保护，也无法避免程序出现问题，析构操作会将锁也析构了。对于智能指针来说，只要有线程访问持有对象的指针，则该对象不会被析构；如果对象要被析构，则所有线程都无法访问该指针。</p>
<h3 id="跨dll资源管理"><a href="#跨dll资源管理" class="headerlink" title="跨dll资源管理"></a>跨dll资源管理</h3><p>某个dll模块如果想要向外界暴露内部资源的指针，如果采用裸指针，就需要注意资源是在内部释放，还是需要外部主动释放问题。一般情况下，我们遵循的原则是<strong>谁创建谁释放</strong>，然而这无法在语言层面上做到约束。对于需要内部释放的资源，如果外部主动释放了，则会导致重复释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RM</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Object* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  ~RM() &#123; <span class="comment">/* destruct all Object */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">RM rm;</span><br><span class="line">Object* o = rm.get(); </span><br><span class="line"><span class="keyword">delete</span> o; <span class="comment">/* error */</span></span><br></pre></td></tr></table></figure>
<p>对于智能指针来说，资源释放都是通过自动垃圾回收机制。使用该dll资源的用户无需关注是否需要释放资源。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>智能指针有利有弊，最严重的问题是延长了对象的生命期。如果不采取特殊的做法，很难保证对象在我们想要析构的地方析构。同时，由于引入了引用计数，会增加拷贝的开销。</p>
<h3 id="延长对象生命期"><a href="#延长对象生命期" class="headerlink" title="延长对象生命期"></a>延长对象生命期</h3><p>由于智能指针<em>std::shared_ptr</em>延长了对象的生命期，所以在使用智能指针时需要明确一件事：在我们希望对象析构后，继续使用该对象没有副作用，否则必须要保证对象在我们想要析构时被析构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt;&gt; objects;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">create</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; po = <span class="built_in">std</span>::make_shared&lt;Object&gt;();</span><br><span class="line">  objects.emplace(index, po);</span><br><span class="line">  <span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  objects.erase(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="keyword">auto</span> po = create(<span class="number">1</span>);</span><br><span class="line">po-&gt;doSomething(); <span class="comment">/* make sure handle po is acceptable after try to destroy po */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line">destroy(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>另一方面，我们无法确定对象在何地析构，也就意味着对象可能在关键线程析构，进而降低了系统的性能。为此，可以用一个单独的线程专门来做析构，通过一个<em>BlockingQueue<std::shared_ptr<void >&gt;</em>把对象析构都转移到那个专用线程中。这种方法的前提就是程序必须要额外开启一条线程。</p>
<h3 id="增加拷贝开销"><a href="#增加拷贝开销" class="headerlink" title="增加拷贝开销"></a>增加拷贝开销</h3><p>智能指针的拷贝相对于裸指针多了引用计数的操作，同时可能还会加锁。所以会增加系统开销。大多数拷贝操作发生在传参，因此推荐使用引用传参方式来替换值传参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; &amp;po)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>智能指针使用过程中难免会遇到一些坑点。本节记录一些注意事项，避免低级失误。</p>
<h3 id="unique-ptr初始化"><a href="#unique-ptr初始化" class="headerlink" title="unique_ptr初始化"></a>unique_ptr初始化</h3><p><em>std::unique_ptr</em>不支持拷贝和赋值。为<em>std::unique_ptr</em>赋初始值有两种方式：<em>new</em>操作和<em>std::make_unique</em>操作。使用这两种方式时都有需要注意的地方：</p>
<ul>
<li><em>std::unique_ptr</em>单参数版本的构造函数是<em>explicit</em>，所以不能使用<em>=</em>赋值；</li>
<li><em>std::make_unique</em>操作是C++14新特性，在某些编译器上是不支持的，在跨平台应用中使用该操作，需要确认是否所有平台都支持该操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up = <span class="keyword">new</span> Object(<span class="number">1</span>); <span class="comment">/* error */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Object(<span class="number">1</span>))</span></span>;  <span class="comment">/* ok     */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up = <span class="built_in">std</span>::make_unique&lt;Object&gt;(<span class="number">1</span>); <span class="comment">/* ok when compiler support */</span></span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr陷阱"><a href="#unique-ptr陷阱" class="headerlink" title="unique_ptr陷阱"></a>unique_ptr陷阱</h3><p>尽量不要将<em>std::unique_ptr</em>和裸指针混用。如果二者混用，会导致资源管理混乱，同时很有可能导致程序奔溃，内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object *b = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; uo1, uo2;</span><br><span class="line">uo1.reset(b);</span><br><span class="line">uo2.reset(b); <span class="comment">/* uo1和uo2将指向同一个位置 */</span></span><br></pre></td></tr></table></figure>
<p><em>release</em>操作并不会释放对象的内存，其仅仅是返回一个指向被管理对象的指针，并释放<em>std::unique_ptr</em>的所有权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; uo = <span class="built_in">std</span>::make_unique&lt;Object&gt;();</span><br><span class="line">Object* o = uo.release();</span><br><span class="line"><span class="keyword">delete</span> o;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr陷阱"><a href="#shared-ptr陷阱" class="headerlink" title="shared_ptr陷阱"></a>shared_ptr陷阱</h3><p>尽量不要通过<em>std::shared_ptr</em>智能指针的<em>get</em>操作获取其指向对象的裸指针。一方面智能指针析构时其变成了空悬指针，另一方面如果不小心<em>delete</em>了裸指针，那么智能指针将会<em>ACCESS VIOLATION</em>。同时，如果你把获取的裸指针继续赋给智能指针的话，又将是一个严重的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; so = <span class="keyword">new</span> Object();</span><br><span class="line">Object *o = so.get();</span><br><span class="line"><span class="keyword">delete</span> o;</span><br><span class="line">so-&gt;doSomething(); <span class="comment">/* access violation */</span></span><br></pre></td></tr></table></figure>
<p>如果要使用智能指针的裸指针，要确保不能将该指针传递到模块外部，同时传递到内部时，也要保证内部对象在智能指针之前释放。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>挖掘点智能指针实际使用过程中的实践经验。</p>
<h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>当使用<em>std::unique_ptr</em>需要注意异常问题。如下代码的执行顺序并不确定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T), function_may_throw());</span><br></pre></td></tr></table></figure>
<p>当上述代码的执行顺序为：<em>new T</em>→<em>function_may_throw()</em>→<em>unique_ptr<T>(…)</em>时，当<em>function_may_throw()</em>抛出异常，则会导致内存泄漏。以下写法能够避免内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">std</span>::make_unique&lt;T&gt;(), function_may_throw());</span><br></pre></td></tr></table></figure>
<p>在C++17中对参数的执行顺序做了约束：</p>
<blockquote>
<p>The initialization of a parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other parameter.</p>
</blockquote>
<p>也就意味上面那个不定执行顺序的代码，只可能有两种执行顺序：</p>
<ul>
<li>顺序一：<em>new T</em>→<em>unique_ptr<T>(…)</em>→<em>function_may_throw()</em></li>
<li>顺序二：<em>function_may_throw()</em>→<em>new T</em>→<em>unique_ptr<T>(…)</em></li>
</ul>
<p>这两种执行顺序都不存在异常安全问题了。不过要求编译器支持C++17。</p>
<blockquote>
<p>注意：<em>std::make_shared</em>和<em>std::make_unique</em>都是异常安全的。</p>
</blockquote>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>对于智能指针，其引用计数增加/减少操作是线程安全的，并且是无锁的。但是其本身并非是线程安全的。因此在多线程访问的情况下，必须要一些同步措施。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; po = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; new_po;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">ScopedLock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">  new_po = po; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; new_po = <span class="keyword">new</span> Object();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">ScopedLock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">  po = new_po;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占资源"><a href="#独占资源" class="headerlink" title="独占资源"></a>独占资源</h3><p>当我们需要独占某个资源时，尽量使用<em>std::unique_ptr</em>，不要使用<em>std::shared_ptr</em>。这样可以避免<em>std::shared_ptr</em>所面临的生命期延长问题。同时，多个<em>std::shared_ptr</em>可以访问修改同一个对象，这在资源独占时是不可接受的。</p>
<p><em>std::shared_ptr</em>相对于<em>std::unqiue_ptr</em>资源开销更大，这是因为<em>std::shared_ptr</em>需要维护一个指向动态内存对象的线程安全的引用计数器。因此，资源独占时，首选<em>std::unique_ptr</em>智能指针。</p>
<h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>RAII，Resource Acquisition Is Initialization，资源获取时就是初始化时。在使用智能指针使尽量避免下面操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object *o = <span class="keyword">new</span> Object;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(o)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这要使用的缺陷在于：</p>
<ul>
<li>无法确保裸指针是否依然有效；</li>
<li>无法确保裸指针不会被二次赋给智能指针。</li>
</ul>
<h3 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h3><p>如果你使用智能指针管理的资源不是<em>new</em>分配的内存，记住传递给它一个删除器。注意使用<em>new []</em>分配的数组，也必须要使用删除器，否则会导致资源泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(<span class="keyword">new</span> Object[<span class="number">10</span>], [](Object *o)&#123;<span class="keyword">delete</span>[]p&#125;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(<span class="keyword">new</span> Object[<span class="number">10</span>], default_deleter&lt;Object[]&gt;())</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要注意，<em>std::unique_ptr</em>是支持管理数组的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object[]) uo(<span class="keyword">new</span> A[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p><em>std::unique_ptr</em>的删除器有两种实现方式：函数指针、类对象和lambda表达式。上文已经给出了lambda表达式的写法。下面给出其他两个的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CConnect</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(CConnect *obj)</span> </span>&#123;</span><br><span class="line">  obj-&gt;disconnect();</span><br><span class="line">  <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">std::unique_ptr&lt;CConnect, decltype(Deleter)*&gt; up(new CConnect, deleter);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deleter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(CConnect *obj)</span> </span>&#123;</span><br><span class="line">    obj-&gt;disconnect();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::unique_ptr&lt;CConnect, Deleter&gt; up1(new CConnect);</span><br><span class="line">std::unique_ptr&lt;CConnect, Deleter&gt; up2(new CConnect, up1.get_deleter());</span><br></pre></td></tr></table></figure>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>使用<em>std::shared_ptr</em>时要避免循环引用。这也是<em>std::weak_ptr</em>存在的价值。建议在设计类时，如果不需要资源的所有权，而不要求控制对象的生命期时，使用<em>std::weak_ptr</em>替代<em>std::shared_ptr</em>。<em>std::weak_ptr</em>不存在延长对象生命期的问题。</p>
<p>循环引用的经典案例为列表，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; _pre;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; _next;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_pre = n1;</span><br></pre></td></tr></table></figure>
<p>要想打破循环引用，则需要借助<em>std::weak_ptr</em>的力量，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Node&gt; _pre;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Node&gt; _next;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_pre = n1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; spn = n2-&gt;_pre.lock();</span><br><span class="line"><span class="keyword">if</span> (spn) &#123;</span><br><span class="line">  spn-&gt;doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://ootips.org/yonat/4dev/smart-pointers.html">Smart Pointers - What, Why, Which?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19472550/exception-safety-and-make-unique">Exception safety and make_unique</a></li>
</ul>

            <hr>
            <blockquote>
            <p>
                本文作者：ZeroJiu
                <br>
                本文链接：<a href="https://www.freehacker.cn/advanced/smartpointer-analysis/"> https://www.freehacker.cn/advanced/smartpointer-analysis/</a>
                <br>
                版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
                <br>
                温馨提示：开启科学上网访问本站，能获得更好的阅读体验，并启用Disqus评论功能和作者交流。
            </p>
            </blockquote>
		  </section>

		  <footer class="post-footer">
			<figure class="author-image">
    <a class="img" href="/about" style="background-image: url(http://ww1.sinaimg.cn/large/61b57e82gw1f1v79yu8v1j20hs0kwdht.jpg)"><span class="hidden">John O&#x27;Nolan's Picture</span></a>
</figure>
<section class="author">
    <a href="/about">ZeroJiu</a>
    <p>骆驼、狮子、婴儿</p>
	<div class="author-meta">
      <span class="author-location icon-location">Jiu, China</span>
      <span class="author-link icon-link"><a target="_blank" rel="noopener" href="http://weibo.com/xpringlee">http://weibo.com/xpringlee</a></span>           
	</div>
</section>
		  </footer>
	  </article>
	  

<aside class="read-next">
	
		<a class="read-next-story " style="background-image: url(http://wx3.sinaimg.cn/large/61b57e82gy1frofy4yu8dj21gs0i279l.jpg)" href="/comm/tcc-vs-gcc/">
			<section class="post">
				<h3>WebRTC-GCC两种实现方案对比</h1>
				<p>从实验仿真的角度，研究GCC算法的优缺点，同时给出TCC和GCC两种实现机制的对比。</p>
			</section>
		</a>
	

	
		<a class="read-next-story prev" style="background-image: url(http://wx2.sinaimg.cn/large/61b57e82gy1fqyfihxtm9j21gs0i2421.jpg)" href="/reading/read-201812/">
			<section class="post">
				<h3>十二月、阅读、思考、实践、反思</h1>
				<p>阅读、思考、实践、反思</p>
			</section>
		</a>
	
</aside>

	  <div id="comment" class="comments-area post">
	
        <div id="disqus_thread"></div>
        <script type="text/javascript">

        var disqus_config = function () {
        this.page.url = 'https://www.freehacker.cn/advanced/smartpointer-analysis/';
        this.page.identifier = 'advanced/smartpointer-analysis/';
        };

        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://zerojiu.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	
</div>

	</main>



	<footer class="site-footer clearfix">
     <section class="copyright"><a href="/about">小熊糖否——木子兮的自留地</a> &copy; 2015-2019 &bull; All rights reserved.</section>
</footer>

  </div>
  <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>
<script type="text/javascript" src="/js/search.js"></script>

<script src="//cdn.bootcss.com/highlight.js/8.5/highlight.min.js"></script>

<script>
hljs.configure({useBR: true});

$('td.code').each(function(i, block) {
  hljs.highlightBlock(block);
});
</script>

<script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?72a6704a58b486ff2fcfcb96b3dac9dd";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script type="text/javascript">
     var search_path = "search.xml";
     if (search_path.length == 0) {
     	search_path = "search.xml";
     }
     var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>