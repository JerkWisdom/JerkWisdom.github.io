<!DOCTYPE html>
<html>

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>C++并发编程2——为共享数据加锁 | 小熊糖否——木子兮的自留地</title>
  <meta name="description" content="C++11中引入了多线程编程，一般教科书中都没有涉及到这个概念，但是在工作中多线程却又是必不可少的。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++并发编程2——为共享数据加锁">
<meta property="og:url" content="https://www.freehacker.cn/foundation/cpp-thread-data-sharing/index.html">
<meta property="og:site_name" content="小熊糖否——木子兮的自留地">
<meta property="og:description" content="C++11中引入了多线程编程，一般教科书中都没有涉及到这个概念，但是在工作中多线程却又是必不可少的。">
<meta property="og:locale">
<meta property="article:published_time" content="2016-09-27T09:38:25.000Z">
<meta property="article:modified_time" content="2020-10-27T04:47:05.355Z">
<meta property="article:author" content="ZeroJiu">
<meta property="article:tag" content="CPlusPlus">
<meta property="article:tag" content="Thread">
<meta name="twitter:card" content="summary">
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="/favicon.ico">

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.5/styles/monokai_sublime.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css">

  <meta name="generator" content="小熊糖否——木子兮的自留地">


  
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  

  <!--载入js，在</body>之前插入即可-->
  <!--Leancloud 操作库:-->
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <!--Valine 的核心代码库-->
  <script src="../../source/js/Valine.min.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body class="post-template nav-closed ">

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
            <li class="nav-home nav-current" role="presentation"><a href="/">Home</a></li>
			<li class="nav-developing" role="presentation"><a href="/categories/Developing">Developing</a></li>
            <li class="nav-reading" role="presentation"><a href="/categories/Reading">Reading</a></li>
			<li class="nav-utility" role="presentation"><a href="/categories/Utility">Utility</a></li>
			<li class="nav-timecapsule" role="presentation"><a href="/categories/TimeCapsule">TimeCapsule</a></li>
            <li class="nav-wikipedia" role="presentation"><a target="_blank" rel="noopener" href="https://wikipedia.freehacker.cn">Wikipedia</a></li>
			<li class="nav-search" role="presentation"><a href="/search/">Search</a></li>
			<li class="nav-about" role="presentation"><a href="/about/">About</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/atom.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

  <div class="site-wrapper">
	


	<header class="main-header post-head" style="background-image: url(http://ww1.sinaimg.cn/large/61b57e82gw1f2ro2bxcqjj21gs0i2wlw.jpg)">
		<nav class="main-nav overlay clearfix">
			<a class="blog-logo" href="/"><img src="http://ww3.sinaimg.cn/large/61b57e82gw1f9hqu7hp7kj2068020wea.jpg" alt="Blog Logo"/></a>
			<a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
		</nav>
		<div class="vertical">
			<div class="main-header-content inner">
				<a class="page-title"></a>
				<a class="page-description"> </a>
			</div>
		</div>
	</header>
	

	<main class="content" role="main">
	  <article class="post">
		  <header class="post-header">
			<h1 class="post-title">C++并发编程2——为共享数据加锁</h1>
			<footer class="post-meta">
	<img class="author-thumb" src="http://ww1.sinaimg.cn/large/61b57e82gw1f1v79yu8v1j20hs0kwdht.jpg" alt="ZeroJiu" />
    <a href="/about">ZeroJiu</a>
	
    On
    
	
    <a href='/tags/CPlusPlus/'>CPlusPlus</a> /
    
    <a href='/tags/Thread/'>Thread</a>
    
    
    At
    <time class="post-date" datetime="2016-09-27T09:38:25.000Z" >
          2016-09-27
    </time>
</footer>

		  </header>
          

		  <section class="post-content">
			<blockquote>
<p>找到问题的解决办法，而不是找蹩脚的接口。</p>
</blockquote>
<p>在应届生面试的时候，很多面试官都会问——“多线程如何共享资源”。在操作系统层面上可以给出若干关键词答案，但是在语言层面，这个问题考虑的就没有那么简单了。<a id="more"></a>同时，很多人会将多线程数据共享和线程同步混淆。有关线程同步，我们会在接下来的章节里着重阐述。本文主要聚焦于保护共享数据，首先从加锁入手，进而扩展到加锁无法解决的问题，最后会给出一些其他保护方案。</p>
<h2 id="参数入栈"><a href="#参数入栈" class="headerlink" title="参数入栈"></a>参数入栈</h2><p>一个存放参数的栈数据结构，相同函数的参数必须要在栈中相连，我们来实现这个功能，看下面代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MutexTest(): m_charStack() &#123; &#125;</span><br><span class="line">    ~MutexTest() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_charStack.push(c);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; m_charStack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MutexTest test;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">mutexTestThread1</span><span class="params">(&amp;MutexTest::Push, &amp;test, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">mutexTestThread2</span><span class="params">(&amp;MutexTest::Push, &amp;test, <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">mutexTestThread1.join();</span><br><span class="line">mutexTestThread2.join();</span><br></pre></td></tr></table></figure>
<p>上面这段代码的执行结果是不确定的，这是因为<strong>我们无法预测线程的执行顺序，多个线程共享同一个数据栈存在竞态条件（Race Condition）。</strong>所以我们可能得到下面的执行结果，所有的参数都是交叉在一起的，这不是我们想要的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabbbbbbbaaaaaaaabbb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>竞态条件</code>是多线程编程的噩梦，为什么会出现竞态条件可以自行百度，我们主要是为了解决这个问题。让最终执行的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaa</span><br><span class="line">bbbbbbbbbb</span><br></pre></td></tr></table></figure></p>
<h2 id="参数入栈保护"><a href="#参数入栈保护" class="headerlink" title="参数入栈保护"></a>参数入栈保护</h2><p><code>std::mutex</code>是C++11提供的数据加锁类，C++中通过实例化 std::mutex 创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MutexTest(): m_mutex(), m_charStack() &#123; &#125;</span><br><span class="line">    ~MutexTest() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex().lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_charStack.push(c);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_mutex().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex       m_mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; m_charStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码和上面的不同点就是使用std::mutex，在访问m_charStack之前上锁，其他线程就必须要等待解锁后才能访问m_charStack。如果我们忘记解锁，那么m_charStack就再也无法被访问了，所以有必要用RAII类<code>std::lock_guard</code>进行封装——构造时上锁，析构时解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MutexTest::Push</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lg</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_charStack.push(c);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++还提供了<code>std::unique_lock</code>锁，相对于<code>std::lock_guard</code>，该锁提供了更好地上锁和解锁灵活性控制。<code>std::unique_lock</code>以独占所有权的方式来管理mutex对象的上锁和解锁操作。我们来看看其用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;thread&gt;   </span><br><span class="line">#include &lt;mutex&gt;      </span><br><span class="line"></span><br><span class="line">std::mutex foo,bar;</span><br><span class="line"></span><br><span class="line">void task_a () &#123;</span><br><span class="line">  &#x2F;* simultaneous lock (prevents deadlock) *&#x2F;</span><br><span class="line">  std::lock (foo,bar);         </span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck1 (foo,std::adopt_lock);</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck2 (bar,std::adopt_lock);</span><br><span class="line">  std::cout &lt;&lt; &quot;task a\n&quot;;</span><br><span class="line">  &#x2F;* (unlocked automatically on destruction of lck1 and lck2) *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task_b () &#123;</span><br><span class="line">  &#x2F;* foo.lock(); bar.lock(); &#x2F;&#x2F; replaced by: *&#x2F;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck1, lck2;</span><br><span class="line">  lck1 &#x3D; std::unique_lock&lt;std::mutex&gt;(bar,std::defer_lock);</span><br><span class="line">  lck2 &#x3D; std::unique_lock&lt;std::mutex&gt;(foo,std::defer_lock);</span><br><span class="line">  &#x2F;* simultaneous lock (prevents deadlock) *&#x2F;</span><br><span class="line">  std::lock (lck1,lck2);       </span><br><span class="line">  std::cout &lt;&lt; &quot;task b\n&quot;;</span><br><span class="line">  &#x2F;* (unlocked automatically on destruction of lck1 and lck2) *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::thread th1 (task_a);</span><br><span class="line">  std::thread th2 (task_b);</span><br><span class="line"></span><br><span class="line">  th1.join();</span><br><span class="line">  th2.join();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们终于得到了我们想要的结果，可惜在很多时候加锁并不是解决数据共享的万能药。std::mutex并不能完全解决保护数据的问题。存在好几种情况，即使我们已经使用了互斥量，数据还是被破坏了。</p>
<ul>
<li>将被保护数据暴露到互斥量作用域之外</li>
<li>被保护数据的访问接口本身就存在竞态条件（条件竞争）</li>
</ul>
<h2 id="不要暴露你的数据"><a href="#不要暴露你的数据" class="headerlink" title="不要暴露你的数据"></a>不要暴露你的数据</h2><p>来看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct protected_data</span><br><span class="line">&#123;</span><br><span class="line">    char data[100];</span><br><span class="line">&#125;</span><br><span class="line">class MutexTest</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename Function&gt;</span><br><span class="line">    void process(Function func)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard&lt;m_dataMutex&gt;;        </span><br><span class="line">        func(m_data);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::mutex            m_dataMutex;</span><br><span class="line">    struct protected_data m_data;</span><br><span class="line">&#125;</span><br><span class="line">struct protected_data *pData;</span><br><span class="line">void inject(Data &amp;data)</span><br><span class="line">&#123;</span><br><span class="line">    pData &#x3D; &amp;data;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 即使process没有显式传出，但是还是被inject传出 *&#x2F;</span><br><span class="line">&#x2F;* process执行完后，pData能在无锁的情况下访问数据 *&#x2F;</span><br><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">    process(inject);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 100; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pData.data[i] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::thread mutexTestThread1(Test);</span><br><span class="line">std::thread mutexTestThread2(Test);</span><br></pre></td></tr></table></figure>
<p>我想不到比较好的例子来说明这个问题，上面的例子是基于C++并发编程上面改编的例子，其也能说明问题：<strong>在上锁后执行了用户定义的函数，将被保护数据传递到互斥锁作用域之外</strong>。</p>
<p>这个场景，<code>mutexTestThread1</code>解锁，<code>mutexTestThread2</code>上锁后，<code>mutexTestThread2</code>仍然无法独占被保护数据。pData总是获取到了被保护的数据，并在<code>mutexTestThread2</code>访问数据时修改该数据。</p>
<p>这种代码看起来很正常，也很不容易被发现，但是背后的错误逻辑是致命的，数据常常被莫名修改，奔溃也有可能随之而来。</p>
<blockquote>
<p><strong>切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。</strong></p>
</blockquote>
<h2 id="谨慎的设计你的数据接口"><a href="#谨慎的设计你的数据接口" class="headerlink" title="谨慎的设计你的数据接口"></a>谨慎的设计你的数据接口</h2><p>来看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;int&gt; intDeque(1, 10);</span><br><span class="line">std::stack&lt;int&gt; intStack(intDeque);</span><br><span class="line">void Process()</span><br><span class="line">&#123;</span><br><span class="line">    if(!intStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        const int value &#x3D; intStack.top();</span><br><span class="line">        intStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::thread t1(Process);</span><br><span class="line">std::thread t2(Process);</span><br></pre></td></tr></table></figure>
<p>即使top()操作和pop()操作都已经上锁，也无法解决条件竞争的问题。</p>
<p>假设栈的实现中对数据的访问已加锁，在单线程情况下，上面程序可以无误执行，但是在多线程情况下，就有可能出现异常。<strong>调用空stack的top()是未定义行为。</strong>在多线程情况下，intStack.empty()操作获取的结果是不可靠的。</p>
<p>上述例子中intStack栈只有一个元素，如果线程t1和t2的执行顺序如下，就会出现未定义行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example 1</span><br><span class="line">t1: intStack.empty() &#x2F;* one element in intStack *&#x2F;</span><br><span class="line">t1: intStack.top()   &#x2F;* one element in intStack *&#x2F;</span><br><span class="line">t2: intStack.empty() &#x2F;* one element in intStack *&#x2F;</span><br><span class="line">t1: intStack.pop()   &#x2F;* no element in intStack  *&#x2F;</span><br><span class="line">t2: intStack.top()   &#x2F;* undefined behavior, intStack is empty() *&#x2F;</span><br></pre></td></tr></table></figure>
<p>即使不出现未定义行为，也有可能出现非预期行为——处理同一份数据多次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* example 2 *&#x2F;</span><br><span class="line">t1: intStack.empty() &#x2F;* one element in intStack *&#x2F;</span><br><span class="line">t2: intStack.empty() &#x2F;* one element in intStack *&#x2F;</span><br><span class="line">t1: intStack.top()   &#x2F;* handle this data *&#x2F;</span><br><span class="line">t2: intStack.top()   &#x2F;* handle this data again *&#x2F;</span><br></pre></td></tr></table></figure>
<p>要解决上述问题，就需要接口设计上有较大的改动，最好的操作是重新设计接口</p>
<ul>
<li>1、重新设计接口实现：top()接口内提供异常机制，当栈大小为零时，抛出异常</li>
<li>2、重新设计接口功能：将pop()和top()操作合并</li>
</ul>
<p>第1种方案并不能解决example 2，所以推荐重新设计接口功能。一个线程安全的栈类定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    std::stack&lt;T&gt;      m_data;</span><br><span class="line">    mutable std::mutex m_mutex;</span><br><span class="line">public:</span><br><span class="line">    Stack(): m_data(std::stack&lt;int&gt;())&#123;&#125;</span><br><span class="line">    Stack(const Stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(other.m);</span><br><span class="line">        data &#x3D; other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&amp; operator&#x3D;(const Stack&amp;) &#x3D; delete;</span><br><span class="line">    void push(T new_value)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;T&gt; pop()</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        if(data.empty()) nullptr;</span><br><span class="line">        const std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data.top()));</span><br><span class="line">        data.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop(T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        if(data.empty()) return nullptr;</span><br><span class="line">        value&#x3D;data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    bool empty() const</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        return data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>栈操作为什么需要先top()后pop()，而不直接pop()时返回数据？这是为了防止pop()时的拷贝操作失败，导致数据丢失。</p>
</blockquote>
<p>如果不重新设计接口，在使用的时候加锁也能解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex stackMutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_gurad&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(statckMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!intStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> value = intStack.top();</span><br><span class="line">        intStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两种可能导致加锁失效的竞态条件场景，需要我们在组织代码或设计接口时精雕细琢，在很多场景下，提供线程安全的代码是很有必要的。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>使用多线程，我们会遇到死锁问题，即使没有加锁，也是有可能出现死锁，必须要按照一定的规范来涉及代码，才能有效的避免死锁问题。</p>
<p>死锁的概念略去不说，死锁有可能发生在使用多个互斥量的场景下，也可能存在没有使用互斥量的场景：</p>
<ul>
<li>两个线程都在等待对方释放互斥量</li>
<li>两个线程都调用了对方的join()函数</li>
</ul>
<p>为了解决<strong>两个线程都在等待对方释放互斥量</strong>导致的死锁问题，C++11提供了若干机制：</p>
<ul>
<li>std::lock()函数</li>
<li>std::unique_lock类</li>
</ul>
<h2 id="锁住所有互斥量"><a href="#锁住所有互斥量" class="headerlink" title="锁住所有互斥量"></a>锁住所有互斥量</h2><p>只要将互斥量作为参数传递给std::lock()，std::lock()就能够锁住多个互斥量。std::lock()并未指定解锁和上锁的顺序，其能够保证：</p>
<ul>
<li>std::lock()执行成功时，所有互斥量都已经被上锁，并且没有死锁问题</li>
<li>std::lock()执行失败时，已被其上锁的互斥量都会被解锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       /* std::cout */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         /* std::thread */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          /* std::mutex, std::lock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    some_big_object(<span class="keyword">int</span> a) :x(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object&amp; some_detail;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object &amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::lock(lhs.m,rhs.m);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; lhs,T&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;some_big_object&gt;(some_big_object &amp;x, some_big_object &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    X a(x), b(y);</span><br><span class="line">    swap(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    some_big_object a(1),b(2);</span><br><span class="line">    a.Print(), b.Print();</span><br><span class="line">    swap(a,b);</span><br><span class="line">    a.Print(), b.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面一段代码使用了模板的偏特化特性，这里不需要深究，只需要知道swap(a, b)最终会调用X类的swap友元函数。在该友元函数中，std::lock()函数锁住两个互斥量，std::lock_guard负责unlock两个互斥量，如果不调用std::lock_guard()，需要手动unlock()。<code>std::adopt_lock</code>参数表示互斥量已经上锁，这里仅仅是不会重复上锁。下面两个例子起到相同作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example 1 */</span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::lock(mtx); <span class="comment">// have to lock before the next sentence</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mtx, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* example 2 */</span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::lock(mtx);</span><br><span class="line">mtx.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="避免死锁的一点建议"><a href="#避免死锁的一点建议" class="headerlink" title="避免死锁的一点建议"></a>避免死锁的一点建议</h2><p>C++并发编程中给出了几点避免死锁的进阶指导：</p>
<ul>
<li>1、避免嵌套锁</li>
<li>2、避免在持有锁时调用用户提供的代码</li>
<li>3、使用固定顺序获取锁</li>
<li>4、使用锁的层次结构</li>
</ul>
<p>前三个建议看字面意思就可以了，我们这里主要阐述锁的层次结构。层次锁需要遵守如下原则：</p>
<blockquote>
<p>当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">7000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> do_low_level_stuff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>;</span><br><span class="line">  high_level_stuff(low_level_func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(middle_level_mutex)</span></span>;</span><br><span class="line">  middle_level_stuff(high_level_stuff());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    high_level_func();</span><br><span class="line">    middle_level_func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照层次锁的原则，high_level_func()能够正确执行，而middle_level_func()不能正确执行：</p>
<ul>
<li>high_level_func()先获取到高层级的锁，然后获取到低层级的锁，符合原则</li>
<li>middle_level_func()先获取低层级的锁，然后获取到高层级的锁，不符合原则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex internal_mutex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;</span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line">      hierarchy_value(value),</span><br><span class="line">      previous_hierarchy_value(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    internal_mutex.lock();</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;</span><br><span class="line">    internal_mutex.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.try_lock())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h2><p>为了防止共享数据初始化时数据被破坏，C++提供了std::once_flag和std::call_once来保证共享数据初始化的正确性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* using mutex *&#x2F;</span><br><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(resource_mutex);</span><br><span class="line">    if(!resource_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resource_ptr.reset(new some_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    lk.unlock();</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* using call_once *&#x2F;</span><br><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;</span><br><span class="line"></span><br><span class="line">void int_resource()</span><br><span class="line">&#123;</span><br><span class="line">    resource_ptr.reset(new some_resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    std::call_once(resource_flag, init_resource);</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="保护很少更新的数据量"><a href="#保护很少更新的数据量" class="headerlink" title="保护很少更新的数据量"></a>保护很少更新的数据量</h2><p>对于这种共享数据可以采用“读者-写着锁”，其允许两种不同的使用方式：一个作者线程独占访问和共享访问，让多个读者线程并发访问。</p>
<p>C++标准并没有提供相关的解决方案，我们可以使用boost::shared_mutex来做同步。对于更新操作，可以使<br>用<code>std::lock_guard&lt;boost::shared_mutex&gt;</code>和<code>std::unique_lock&lt;boost::shared_mutex&gt;</code>进行上锁；对于访问操作，可以使用<code>boost::shared_lock&lt;boost::shared_mutex&gt;</code>获取共享访问权。我们来看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;boost&#x2F;thread&#x2F;shared_mutex.hpp&gt;</span><br><span class="line">class dns_entry;</span><br><span class="line">class dns_cache</span><br><span class="line">&#123;</span><br><span class="line">  std::map&lt;std::string,dns_entry&gt; entries;</span><br><span class="line">  mutable boost::shared_mutex entry_mutex;</span><br><span class="line">public:</span><br><span class="line">  dns_entry find_entry(std::string const&amp; domain) const</span><br><span class="line">  &#123;</span><br><span class="line">    boost::shared_lock&lt;boost::shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">    std::map&lt;std::string,dns_entry&gt;::const_iterator const it&#x3D;</span><br><span class="line">       entries.find(domain);</span><br><span class="line">    return (it&#x3D;&#x3D;entries.end())?dns_entry():it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  void update_or_add_entry(std::string const&amp; domain,</span><br><span class="line">                           dns_entry const&amp; dns_details)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;boost::shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">    entries[domain]&#x3D;dns_details;</span><br><span class="line">&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码，find_entry()使用了<code>boost::shared_lock&lt;&gt;</code>实例来保护器共享和只读权限；update_or_add_entry()使用<code>std::lock_guard&lt;&gt;</code>实例来独占访问权限。</p>
<h2 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h2><p>对于一个已经上锁的互斥量多次上锁，会出现未定义行为。然而对于嵌套锁<code>std::recursive_mutex</code>来说，多次上锁不会出现问题。</p>
<p>在互斥量锁住其他线程前,你必须释放你拥有的所有 锁,所以当你调用lock()三次时,你也必须调用unlock()三次。正确使<br>用 std::lock_guard<std::recursive_mutex> 和 std::unique_lock<std::recursice_mutex> 可以帮我们处理这些问题。</p>
<p>大多数情况下，嵌套锁是用在可被多线程并发访问的类上，所以其拥有一个互斥量保护其成员数据。每个公共成员函数 都会对互斥量上锁,然后完成对应的功能,之后再解锁互斥量。不过,有时一个公共成员函 数会调用另一个公共函数作为其操作的一部分。</p>
<p>不过上面提高的方案是不推荐的，推荐的做法是——从中提取出一个函数作为类的私有成员, 并且让所有成员函数都对其进行调用,这个私有成员函数不会对互斥量进行上锁(在调用前必 须获得锁)。</p>

            <hr>
            <blockquote>
            <p>
                本文作者：ZeroJiu
                <br>
                本文链接：<a href="https://www.freehacker.cn/foundation/cpp-thread-data-sharing/"> https://www.freehacker.cn/foundation/cpp-thread-data-sharing/</a>
                <br>
                版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
                <br>
                温馨提示：开启科学上网访问本站，能获得更好的阅读体验，并启用Disqus评论功能和作者交流。
            </p>
            </blockquote>
		  </section>

		  <footer class="post-footer">
			<figure class="author-image">
    <a class="img" href="/about" style="background-image: url(http://ww1.sinaimg.cn/large/61b57e82gw1f1v79yu8v1j20hs0kwdht.jpg)"><span class="hidden">John O&#x27;Nolan's Picture</span></a>
</figure>
<section class="author">
    <a href="/about">ZeroJiu</a>
    <p>骆驼、狮子、婴儿</p>
	<div class="author-meta">
      <span class="author-location icon-location">Jiu, China</span>
      <span class="author-link icon-link"><a target="_blank" rel="noopener" href="http://weibo.com/xpringlee">http://weibo.com/xpringlee</a></span>           
	</div>
</section>
		  </footer>
	  </article>
	  

<aside class="read-next">
	
		<a class="read-next-story " style="background-image: url(http://ww1.sinaimg.cn/large/61b57e82gw1f2ro2bxcqjj21gs0i2wlw.jpg)" href="/foundation/cpp-thread-manager/">
			<section class="post">
				<h3>C++并发编程1——让我们开始管理线程</h1>
				<p>C++11中引入了多线程编程，一般教科书中都没有涉及到这个概念，但是在工作中多线程却又是必不可少的。</p>
			</section>
		</a>
	

	
		<a class="read-next-story prev" style="background-image: url(http://ww2.sinaimg.cn/large/61b57e82gw1f5ydd0qj48j21hc0i240x.jpg)" href="/platform/add-version-info-to-app/">
			<section class="post">
				<h3>如何给应用程序加版本信息</h1>
				<p>右键应用程序的可执行文件，查看详细信息，能够看到应用程序的详细描述，这是怎么加的呢？</p>
			</section>
		</a>
	
</aside>

	  <div id="comment" class="comments-area post">
	
        <div id="disqus_thread"></div>
        <script type="text/javascript">

        var disqus_config = function () {
        this.page.url = 'https://www.freehacker.cn/foundation/cpp-thread-data-sharing/';
        this.page.identifier = 'foundation/cpp-thread-data-sharing/';
        };

        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://zerojiu.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	
</div>

	</main>



	<footer class="site-footer clearfix">
     <section class="copyright"><a href="/about">小熊糖否——木子兮的自留地</a> &copy; 2015-2019 &bull; All rights reserved.</section>
</footer>

  </div>
  <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>
<script type="text/javascript" src="/js/search.js"></script>

<script src="//cdn.bootcss.com/highlight.js/8.5/highlight.min.js"></script>

<script>
hljs.configure({useBR: true});

$('td.code').each(function(i, block) {
  hljs.highlightBlock(block);
});
</script>

<script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?72a6704a58b486ff2fcfcb96b3dac9dd";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script type="text/javascript">
     var search_path = "search.xml";
     if (search_path.length == 0) {
     	search_path = "search.xml";
     }
     var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>