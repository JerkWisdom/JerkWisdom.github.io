<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小熊糖否——木子兮的自留地</title>
  <icon>https://www.gravatar.com/avatar/eeb49492d9ae3e91fc80aaeadffe7c81</icon>
  <subtitle>No Place For Stupid, No Time For Hesitation</subtitle>
  <link href="https://www.freehacker.cn/atom.xml" rel="self"/>
  
  <link href="https://www.freehacker.cn/"/>
  <updated>2020-10-27T04:47:05.373Z</updated>
  <id>https://www.freehacker.cn/</id>
  
  <author>
    <name>ZeroJiu</name>
    <email>xpringlee@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象分析与设计-概念</title>
    <link href="https://www.freehacker.cn/reading/ooad/"/>
    <id>https://www.freehacker.cn/reading/ooad/</id>
    <published>2020-10-27T04:47:05.373Z</published>
    <updated>2020-10-27T04:47:05.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“Success isn’t about how your life looks to others. It’s about how it feels to you.”</p></blockquote><p>面向对象分析与设计全书分为理论和应用两部分，深刻剖析了面向对象分析与设计的概念和方法。<a id="more"></a></p><h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><blockquote><p>软件的复杂性是一个基本特征，而不是偶然如此。——Brooks</p></blockquote><p>如上所述，软件的复杂性是其固有的属性。这种固有的复杂性有4个原因：</p><ul><li>问题域的复杂性</li><li>管理开发过程的困难性</li><li>软件中随处可能出现的灵活性</li><li>刻画离散系统行为的问题</li></ul><p>正因为这种复杂性的本质，所有复杂系统都存在5个共同的属性：</p><ul><li>层次结构</li></ul><blockquote><p>复杂性常常以层次结构的形式存在。复杂的系统由一些相关的子系统组成。这些子系统又有自己的系统，如此下去，直到达到某种最低层次的基本组件。</p></blockquote><ul><li>相对本原</li><li>分离关注</li><li>共同模式</li><li>稳定的中间形式</li></ul><p>软件开发面临的困境是：要开发的软件系统的复杂性在增加，而我们处理复杂性的能力却有局限。怎样才能解决这个困境？</p><ul><li>分解</li><li>抽象</li><li>层次结构</li></ul><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>对象模型主要是为了解决大规模编程的遇到的问题。使用对象模型能够帮助我们探索基于对象和面向对象编程语言的表达能力。利用对象模式不仅鼓励软件的复用，而且鼓励整个设计的复用，这导致了可复用应用框架的产生。使用对象模型将得到构建在稳定的中间状态之上的系统，这样的系统更适合变化。</p><h3 id="OOP、OOD、OOA"><a href="#OOP、OOD、OOA" class="headerlink" title="OOP、OOD、OOA"></a>OOP、OOD、OOA</h3><p><strong>究竟什么是面向对象编程（OOP）？</strong></p><blockquote><p>面向对象编程是一种实现的方法，在这种方法中，程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构。</p></blockquote><p>该定义的要点在于三点，一个程序如果不满足这三点，就不是面向对象编程：</p><ul><li>利用对象作为基本逻辑构建块</li><li>每个对象都是某个类的一个实例</li><li>类与类之间可以通过继承关系联系在一起</li></ul><p><strong>究竟什么是面向对象设计（OOD）？</strong></p><blockquote><p>面向对象设计是一种设计方法，包括面向对象分解的过程和一种表示法，这种表示法用于展示被设计系统的逻辑模型和物理模型、静态模型和动态模型。</p></blockquote><p>对面向对象分解的支持是面向对象设计与结构化设计的不同之处：前者利用类和对象抽象来构建逻辑系统结构，后者则利用算法抽象。</p><p><strong>究竟什么是面向对象分析（OOA）？</strong></p><blockquote><p>面向对象分析是一种分析方法，这种方法利用从问题域的词汇表中找到的类和对象来分析需求。</p></blockquote><p>面向对象分析的重点在于构建真实世界的模型，利用面向对象的观点来看世界。</p><p><strong>OOA、OOD、OOP三者关系如何？</strong></p><p>面向对象分析的结构可以作为开始面向对象设计的模型，面对对象设计的结果可以作为蓝图，利用面向对象编程方法最终实现一个系统。</p><h3 id="对象模型要素"><a href="#对象模型要素" class="headerlink" title="对象模型要素"></a>对象模型要素</h3><p>每一种编程风格都是基于它自己的概念框架。对于所有面向对象的东西，概念框架就是对象模型。这个模型有四个主要要素：</p><ul><li>抽象</li></ul><blockquote><p>抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的视角有关。</p><p>对于给定的问题域决定一组正确的抽象，就是面向对象设计的核心问题。</p></blockquote><ul><li>封装</li></ul><blockquote><p>封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念结构及其实现。</p><p>抽象关注对象的可以观察到的行为，而封装关注这种行为的实现。</p></blockquote><ul><li>模块化</li></ul><blockquote><p>模块化是一个系统的属性，这个系统被分解为一组高内聚（将逻辑上相关的抽象放在一起）、低耦合（减少模块间的依赖关系）的模块。</p><p>抽象、封装、模块化的原则是相辅相成的。一个对象围绕单一的抽象提供一个明确的边界，封装和模块化都围绕这个抽象提供了屏障。</p></blockquote><ul><li>层次结构</li></ul><blockquote><p>层次结构是抽象的一种分级或排序。在复杂系统中，最重要的层次结果是它的类结构（“是一种”层次结构——继承/派生）和对象结构（“组成部分”层次结构——聚合/组合）。</p></blockquote><p>所谓“主要”，指的是如果一个模型不具备这些元素之一，就不是面向对象的。</p><p>对象模型有三个次要要素：</p><ul><li>类型</li></ul><blockquote><p>类型是关于一个对象的类的强制规定，这样一来，不同类型的对象不能够互换使用，或者至少它们的互换使用受到非常严格的限制。</p></blockquote><ul><li>并发</li></ul><blockquote><p>并发时一种属性，它区分主动对象和非主动对象。主动对象可以代表一个独立的控制线程。我们可以将世界概念化为一组协作的对象，其中某些是主动的，因此作为独立活动的中心。</p></blockquote><ul><li>持久</li></ul><blockquote><p>持久是对象的一种属性，利用这种属性，对象跨越时间（例如，当对象的创建不存在了的时候，对象仍然存在）和空间（例如，对象的位置从它被创建的地址空间移开）而存在。</p></blockquote><p>所谓“次要”，指的是这些要素是对象模型的有用组成部分，但不是本质的。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的定义：</p><blockquote><p>一个对象是一个具有状态、行为和标识符的实体。结构和行为类似的对象定义在他们共同的类中。“实例”和“对象”这两个术语可以互换使用。</p></blockquote><p>对象的状态：</p><blockquote><p>对象的状态包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）。</p><p>一个属性是一种内在或独特的特征、特点、品质或特性，使一个对象区别于别的对象。</p></blockquote><p>对象的行为：</p><blockquote><p>行为是对象在状态改变和消息传递方面的动作和反应的方式。对象的行为代表了它外部可见的活动。</p><p>对象的状态影响对象行为的结果，对象的行为改变了对象的状态，一个对象的状态代表了它的行为的积累效果。</p><p>一个对象的行为包含了其操作的综合。常见的操作如下：</p><ul><li>修改操作</li><li>选择操作</li><li>遍历操作</li><li>构造操作</li><li>析构操作</li></ul></blockquote><p>对象的标识符：</p><blockquote><p>标识符是一个对象的属性，它区分这个对象与其他所有对象。</p></blockquote><p>对象之间的关系</p><blockquote><p>链接代表了具体的关联，通过这种关联，一个对象（客户）请求另一个对象（服务提供者）的服务，或者通过这种关联从一个对象导航到另一个对象。</p><p>聚合表明一种整体/部分层次关系，提供了从整体导航到它的部分的能力。</p></blockquote><h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><p>类的定义：</p><blockquote><p>类是一组对象，它们拥有共同的结构、共同的行为和共同的语义。一个对象就是类的一个实例。类起到的作用是在一种抽象和所有它的客户之间建立起协议。通过在类的接口中记录下这些决定，一种强类型的编程语言可以在编译时检查是否违反了这一协议。</p></blockquote><p>类之间的关系：</p><blockquote><p>类之间存在三种基本关系：一般/特殊关系（是“一种”关系，玫瑰是一种花）、整体/部分关系（是”组成部分“关系，花瓣是花的部分）、关联（语义上的依赖关系，瓢虫和花之间的关系）。</p></blockquote><ul><li>继承：一个类实现一个接口或一个类泛化另一个类。是一种<em>is a</em>语意。</li><li>组成：一个类和另一个类是关联的，两个类之间是整体和部分的关系，是一种<em>has a</em>语意。表现为：持有对方的指针，并占有对方的所有权。</li><li>聚合：一个类和另一个类是关联的，两个类之间是整体和局部的关系，是一种<em>has a</em>语意。表现为：持有对方的指针或引用，但不占用对方的所有权。</li><li>关联：一个类和另一个类有关联，两个类之间是平等的关系，是一种<em>has a</em>语意。表现为：持有对方的指针或引用，但不占有对方的所有权。</li><li>依赖：一个类依赖于另一个类的定义，是一种<em>use a</em>语意。表现为：局部变量、方法参数、静态方法调用等。</li></ul><h3 id="类与对象的互动"><a href="#类与对象的互动" class="headerlink" title="类与对象的互动"></a>类与对象的互动</h3><p>在分析阶段和设计的早期阶段，开发者主要有两项任务：</p><ul><li>从问题域的词汇表中确定出类</li><li>创建一些结构，让多组对象一起工作，提供满足问题需求的行为。</li></ul><p>这些类和对象统称为问题的”关键抽象“，把这些协作结构称为实现的”机制“。开发者必须关注这些关键抽象和机制的外部视图——代表系统的逻辑框架，包含了系统的类结构和对象结构。</p><h3 id="创造高品质的类与对象"><a href="#创造高品质的类与对象" class="headerlink" title="创造高品质的类与对象"></a>创造高品质的类与对象</h3><p>如何评判一种抽象的品质：</p><ul><li>耦合</li></ul><blockquote><p>一个模块与另一个模块之间建立起的关联强度的测量。继承引入了严重的耦合。</p><p>创建松散耦合的类——Demeter法则：类的方法不应该以任何方式依赖于任何类的结构，除了他自己类的当前结构之外，而且每个方法只能够对一个非常有限的类集的对象发出消息。</p></blockquote><ul><li>内聚</li></ul><blockquote><p>内聚测量了单个模块内各个元素的联系程度。尽量减少偶然性内聚，使用功能性内聚——一个类或模式的各元素一同工作，提供某种清晰界定的行为。</p></blockquote><ul><li>充分性</li></ul><blockquote><p>充分指的是类或模块应该记录某个抽象足够多的特征，从而允许有意义的、有效的交互。充分意味着最小接口——缺少某个接口该抽象的意义将不存在。</p></blockquote><ul><li>完整性</li></ul><blockquote><p>完整值得是类或模块的接口记录了某个抽象全部有意义的特征。一个完整的接口以为这该接口包含了某个抽象的所有方向。</p></blockquote><ul><li>基础性</li></ul><blockquote><p>基础性操作就是只有访问该抽象的底层表现形式才能够有效地实现的那些操作。譬如对于一个集合的Add操作必须知道该集合的底层表现形式。而Add四个元素并不是基础性操作。</p></blockquote><p>上面这些选项都是创建类时需要考虑的。对于类的操作，是选择太多的函数还是较少的函数；对于类之间的关系，是采用继承、聚合，还是依赖；对于类之间的交互，如何确定对象之间的可见性——这些都需要进行折中权衡考虑。</p><h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><ul><li>经典方法</li></ul><blockquote><p>根据问题域来源来区分</p></blockquote><ul><li>行为分析</li></ul><blockquote><p>将对象的行为作为类和对象的主要来源</p></blockquote><ul><li>领域分析</li></ul><blockquote><p>将领域分析定义为“确定对象、操作和关系的尝试，领域专家认为这些对象、操作和关系对这个领域很重要”。领域分析的步骤如下：</p><ul><li>咨询领域专家，构建一个通用的模型草稿</li><li>检查领域中原有的系统，以一种通用的格式展示出这方面的理解</li><li>咨询领域专家，确定系统间的相似与差异</li><li>精化通用模型，以包含原有的系统。</li></ul><p>清楚设计问题要做的就是让一名领域专家和一名架构师或开发者进行简短的会晤。——领域专家通常不会是一名开发者，其通常是某个领域的用户。</p></blockquote>]]></content>
    
    
    <summary type="html">面向对象分析与设计全书分为理论和应用两部分，深刻剖析了面向对象分析与设计的概念和方法。</summary>
    
    
    <content src="http://wx3.sinaimg.cn/large/61b57e82gy1fpclodaaxoj21hc0gon6r.jpg" type="image"/>
    
    
    <category term="Reading" scheme="https://www.freehacker.cn/categories/Reading/"/>
    
    
    <category term="OOP" scheme="https://www.freehacker.cn/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>过去与未来：创业之路</title>
    <link href="https://www.freehacker.cn/republic/the-road-to-entrepreneurship/"/>
    <id>https://www.freehacker.cn/republic/the-road-to-entrepreneurship/</id>
    <published>2020-07-09T00:32:11.000Z</published>
    <updated>2020-10-27T04:47:05.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>劝君莫惜金缕衣，劝君惜取少年时。花开堪折直须折，莫待无花空折枝。</p><footer><strong>杜十娘</strong><cite>金缕衣</cite></footer></blockquote><p>艰难困苦，玉汝于成；创业维艰，奋斗以成。<a id="more"></a></p><h2 id="20200710"><a href="#20200710" class="headerlink" title="20200710"></a>20200710</h2><h2 id="20200709"><a href="#20200709" class="headerlink" title="20200709"></a>20200709</h2><p>有哪些因素是创业第一要考虑的？</p><p>1、身体</p><p>身体是革命的本钱，身体坏了创业和你没有任何关系。</p><p>改革措施：</p><ul><li>利用一切能够睡觉的时间，保证一天七小时的睡眠，养成规律作息</li><li>利用一切能够锻炼的时间，保证一周三到四次的锻炼</li><li>注意自己的体型，70kg是一个合适值，健康饮食，适度饮酒，不吸烟</li><li>可以加班，不能熬夜，每月熬夜不超过三天，每天十一点前必须要到家</li></ul><p>2、团队</p><p>创业失败的最大原因是创始团队的不和。</p><p>3、产品</p><p>4、资金</p>]]></content>
    
    
    <summary type="html">创业至今三年，仍在创业路上，持续思考，把握未来。</summary>
    
    
    <content src="https://wx3.sinaimg.cn/large/61b57e82ly1g1vmw909c0j21gs0i3jwn.jpg" type="image"/>
    
    
    <category term="TimeCapsule" scheme="https://www.freehacker.cn/categories/TimeCapsule/"/>
    
    
  </entry>
  
  <entry>
    <title>有关字符串翻转reverse的思考</title>
    <link href="https://www.freehacker.cn/reading/reverse/"/>
    <id>https://www.freehacker.cn/reading/reverse/</id>
    <published>2019-02-11T12:46:16.000Z</published>
    <updated>2020-10-27T04:47:05.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>孟子曰：“尽信《书》，则不如无《书》”</p></blockquote><p>陈硕Muduo一书第12章中提及“<strong>用异或交换变量是错误的</strong>”。校招面试的时候经常遇到这个问题，竟然没有深入思考这一点。<a id="more"></a></p><p>首先来看看翻转一个字符串的三种方法：</p><ul><li>方法一：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_by_swap</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *b = str;</span><br><span class="line">  <span class="keyword">char</span>* e = str + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(b &lt; e) &#123;</span><br><span class="line">    <span class="keyword">char</span> t = *b;</span><br><span class="line">    *b = *e;</span><br><span class="line">    *e = t;</span><br><span class="line">    ++b;</span><br><span class="line">    --e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_by_xor</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *b = str;</span><br><span class="line">  <span class="keyword">char</span>* e = str + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">    *b ^= *e;</span><br><span class="line">    *e ^= *b;</span><br><span class="line">    *b ^= *e;</span><br><span class="line">    ++b;</span><br><span class="line">    --e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法三：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_by_std</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::reverse(str, str + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面程序来测试三种方法耗时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Timestamp ts;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    reverse_by_swap(r, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int64_t</span> t1 = ts.elapsed();</span><br><span class="line"></span><br><span class="line">ts.update();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    reverse_by_xor(l, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> t2 = ts.elapsed();</span><br><span class="line"></span><br><span class="line">ts.update();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    <span class="built_in">std</span>::reverse(s, s+ <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> t3 = ts.elapsed();</span><br><span class="line">logger().info(<span class="string">&quot;t1=&quot;</span> + <span class="built_in">std</span>::to_string(t1) + <span class="string">&quot; t2: &quot;</span> + <span class="built_in">std</span>::to_string(t2) + <span class="string">&quot; t3: &quot;</span> + <span class="built_in">std</span>::to_string(t3));</span><br></pre></td></tr></table></figure><p>测试的字符串分为长字符串和短字符串两种（样例随机选择，能够支持最后结论就好）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">&quot;012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&quot;</span>;</span><br></pre></td></tr></table></figure><p>三种方法的时间耗时如下表，单位纳秒：</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符串</th><th style="text-align:center">方法一</th><th style="text-align:center">方法二</th><th style="text-align:center">方法三</th></tr></thead><tbody><tr><td style="text-align:center">str1</td><td style="text-align:center">4960</td><td style="text-align:center">8928</td><td style="text-align:center">6447</td></tr><tr><td style="text-align:center">str2</td><td style="text-align:center">85311</td><td style="text-align:center">230144</td><td style="text-align:center">11904</td></tr></tbody></table></div><p>可以看出方法二的复杂度明显高于其他两个方法，以后在面试的时候可以让学生分析为什么会这样。对于方法一和方法三，在字符串较短时方法一更高效，字符串较长时方法三更高效。在网上搜了一圈，没看出<em>std::reverse</em>是怎么实现的。cppreference给出的可能实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(BidirIt first, BidirIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((first != last) &amp;&amp; (first != --last)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::iter_swap(first++, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种方法的对比得出了几点结论：</p><ul><li>标准库的实现往往是最佳的选择；</li><li>深入思考打败人云亦云；</li><li>没有测试数据作证的揣测都是臆想；</li><li><em>premature optimization is the root of all evil</em>。</li></ul>]]></content>
    
    
    <summary type="html">采用中间值翻转、异或翻转和std::reverse三种翻转对比。</summary>
    
    
    <content src="http://ww3.sinaimg.cn/large/61b57e82gw1f2uru65pboj20zk0bztd6.jpg" type="image"/>
    
    
    <category term="Reading" scheme="https://www.freehacker.cn/categories/Reading/"/>
    
    
    <category term="Experience" scheme="https://www.freehacker.cn/tags/Experience/"/>
    
    <category term="CPlusPlus" scheme="https://www.freehacker.cn/tags/CPlusPlus/"/>
    
  </entry>
  
  <entry>
    <title>十二月、阅读、思考、实践、反思</title>
    <link href="https://www.freehacker.cn/reading/read-201812/"/>
    <id>https://www.freehacker.cn/reading/read-201812/</id>
    <published>2019-01-20T15:31:56.000Z</published>
    <updated>2020-10-27T04:47:05.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”</p></blockquote><p>很少会把一本书看完，经常是看到一半就看不下去了。是书不好，还是人不好？<a id="more"></a></p><h2 id="一个投资家的二十年"><a href="#一个投资家的二十年" class="headerlink" title="一个投资家的二十年"></a>一个投资家的二十年</h2><p><img src="../../assets/reading/a-invester-20.png" alt=""></p><p>点评：虽然无法完全借鉴，但是书中确是有不说真知灼见。重要是学习与参与，然后在实践中检验成果。不一定在股票上，在技术等其他方面，也是能够有一点的借鉴。</p><h2 id="基督山伯爵"><a href="#基督山伯爵" class="headerlink" title="基督山伯爵"></a>基督山伯爵</h2><p><img src="../../assets/reading/le-comte-de-monte-rristo.png" alt=""></p><p>点评：只看了一半，喜欢看简练的文章，这种名著总是让我感觉冗余过度。前半部分看的觉得还算紧凑，后半部分就如裹脚布一样长了。三个火枪手也是只看了前半部分，看样子和大仲马无缘。</p><h2 id="大型网站技术架构"><a href="#大型网站技术架构" class="headerlink" title="大型网站技术架构"></a>大型网站技术架构</h2><p><img src="../../assets/reading/large-network-arch.png" alt=""></p><p>点评：按照高并发、高可用、可扩展等多个维度娓娓道来，从整体出发介绍了方方面面，对入门分布式相关架构知识很有帮助。主要问题在于，过于泛，要想掌握还需要针对每个内容点，重新寻找更深入的学习资料深入研究。</p><h2 id="微习惯"><a href="#微习惯" class="headerlink" title="微习惯"></a>微习惯</h2><p><img src="../../assets/reading/micro-hobit.png" alt=""></p><p>点评：此类书籍看了很多，就是为何对我不起作用。书中作者都说看得人都感同身受，觉得起了很大的改变。但我觉得这似乎是故意对自己的欺骗，可是我无法欺骗自己。</p><h2 id="韭菜的自我修养"><a href="#韭菜的自我修养" class="headerlink" title="韭菜的自我修养"></a>韭菜的自我修养</h2><p><img src="../../assets/reading/jucai.png" alt=""></p><p>点评：大鱼吃小鱼，小鱼吃虾米。知识+谋略+坚持，韭菜也有春天。这本书看样子像是李笑来的辩解，不过还是挺有道理的。</p><h2 id="深度思考-不断逼近问题的本质"><a href="#深度思考-不断逼近问题的本质" class="headerlink" title="深度思考 - 不断逼近问题的本质"></a>深度思考 - 不断逼近问题的本质</h2><p><img src="../../assets/reading/deep-thinking.png" alt=""></p><p>点评：感觉书名取巧了，如果他要是写成某某某自传我是不会去看的。这本书可以让女性借鉴如何在职场上更进一步。但所谓的深度思考，逼近问题的本质缺少更加普遍的适应能力。</p><h2 id="怪诞心理学"><a href="#怪诞心理学" class="headerlink" title="怪诞心理学"></a>怪诞心理学</h2><p><img src="../../assets/reading/grotesque-psychology.png" alt=""></p><p>点评：并不觉得有多怪诞，只是比较有意思，关注的是一些平时不会关心的地方。按照我们平民百姓的说法，就是吃饱着撑了瞎想。不过还是挺有意思的。</p><h2 id="腾讯传"><a href="#腾讯传" class="headerlink" title="腾讯传"></a>腾讯传</h2><p><img src="../../assets/reading/tencent.png" alt=""></p><p>点评：腾讯的历史，是中国互联网二十年的历史。书中可以看出商场就是战场，没有永恒的敌人，也没有永远的朋友。再大的公司也可能在危机面前瞬间坍塌。</p>]]></content>
    
    
    <summary type="html">阅读、思考、实践、反思</summary>
    
    
    <content src="http://wx2.sinaimg.cn/large/61b57e82gy1fqyfihxtm9j21gs0i2421.jpg" type="image"/>
    
    
    <category term="Reading" scheme="https://www.freehacker.cn/categories/Reading/"/>
    
    
    <category term="Book" scheme="https://www.freehacker.cn/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>智能指针二三事</title>
    <link href="https://www.freehacker.cn/advanced/smartpointer-analysis/"/>
    <id>https://www.freehacker.cn/advanced/smartpointer-analysis/</id>
    <published>2018-10-13T00:48:41.000Z</published>
    <updated>2020-10-27T04:47:05.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>韭菜的自我修养。</p><footer><strong>李笑来</strong></footer></blockquote><p>C++11中引入智能指针，智能指针主要用来解决资源管理中遇到的各种问题。在引入智能指针之前，我们必须要操作裸指针，裸指针是导致内存问题的罪魁祸首——空悬指针、内存泄漏、分配失败等。一些著名的开源C项目，现在仍然还需要面临着一些由裸指针引起的内存问题。<a id="more"></a></p><p>如何使用智能指针能够轻易地在C++11标准中找到，如何用好智能指针却并不是那么简单。我们必须要清楚：</p><ul><li>智能指针解决了哪些问题？</li><li>智能指针引入了哪些问题？</li><li>智能指针使用存在哪些坑？</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>C++11标准库中，智能指针主要包含<em>unique_ptr</em>、<em>shared_ptr</em>、<em>weak_ptr</em>三种。这三种智能指针已经能够解决我们遇到的大多数问题。这些问题包含：</p><ul><li>内存泄漏</li><li>指针有效性检测</li><li>资源独占</li><li>多线程资源管理</li><li>跨dll资源管理</li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>智能指针能够实现自动垃圾回收（Automatic Garbage Collection），这有效的解决了程序中部分内存/资源泄漏问题。智能指针能够有效地防止由于程序<strong>异常</strong>而导致的资源泄漏。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object* p = <span class="keyword">new</span> Object();</span><br><span class="line">    p-&gt;doSomething(); <span class="comment">/* throw exception */</span></span><br><span class="line">    <span class="keyword">delete</span> p;         <span class="comment">/* memory leak and resource leak in Object */</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    p-&gt;doSomething(); <span class="comment">/* throw exception */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针有效性检测"><a href="#指针有效性检测" class="headerlink" title="指针有效性检测"></a>指针有效性检测</h3><p>裸指针只能检测指针是否是nullptr，无法检测出指针指向的对象是否有效。而智能指针能够检测其所指向对象的有效性。</p><p>裸指针若不初始化，其值是一个随机值，也就是野指针，而智能指针会默认初始化为nullptr。编译器一般会对<strong>使用未初始化的野指针</strong>报错，若不报错我们则会面临程序奔溃、内存越界的风险。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p;   <span class="comment">/* p为野指针 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* pp; <span class="comment">/* pp非野指针 */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">char</span>&gt; sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>裸指针指向的对象被销毁后，未将裸指针设置为nullptr，则裸指针称为空悬指针。出现空悬指针的情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    p = &amp;c;</span><br><span class="line">  &#125; <span class="comment">/* c释放，p为空悬指针 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">/* p为空悬指针 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;num; <span class="comment">/* 返回一个空悬指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问空悬指针程序会抛出异常<em>write access violation</em>。而对智能指针，只有指针生命期结束或主动指向其他对象时，其所指向的对象才会被销毁（引用计数减一）。故而，智能指针不存在空悬指针问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>); <span class="comment">/* 对象释放后又重新构造一个对象，sp1可以继续使用 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);  </span><br><span class="line">  &#125; <span class="comment">/* 对象释放，但也无法使用sp2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源独占"><a href="#资源独占" class="headerlink" title="资源独占"></a>资源独占</h3><p>裸指针无法保证资源独占，可能会存在多个指针指向同一个对象，进而导致一些难以控制的问题。譬如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object *p1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object *p2 = p1;</span><br><span class="line">  <span class="keyword">delete</span> p1;</span><br><span class="line">  *p2; <span class="comment">/* 空悬指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针中的<em>std::unique_ptr</em>能够独占资源所有权，某时某刻只有一个<em>std::unique_ptr</em>指向特定的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> Object())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up2 = up1; <span class="comment">/* error */</span></span><br><span class="line">  up2 = <span class="built_in">std</span>::move(up1); <span class="comment">/* up1转移所有权给up2，up1为nullptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程资源管理"><a href="#多线程资源管理" class="headerlink" title="多线程资源管理"></a>多线程资源管理</h3><p>智能指针能够很好地解决多线程情况下对象析构问题。这是裸指针难以办到的。对于裸指针来说，如果一个线程要访问该指针，而另一个线程需要delete该指针，后果难以想象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~T() &#123; <span class="comment">/* destruct resource in mutex */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">/* update resource in mutex*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> T *t;</span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">t = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line"><span class="keyword">if</span> (t) t-&gt;update();</span><br></pre></td></tr></table></figure><p>即使有锁的保护，也无法避免程序出现问题，析构操作会将锁也析构了。对于智能指针来说，只要有线程访问持有对象的指针，则该对象不会被析构；如果对象要被析构，则所有线程都无法访问该指针。</p><h3 id="跨dll资源管理"><a href="#跨dll资源管理" class="headerlink" title="跨dll资源管理"></a>跨dll资源管理</h3><p>某个dll模块如果想要向外界暴露内部资源的指针，如果采用裸指针，就需要注意资源是在内部释放，还是需要外部主动释放问题。一般情况下，我们遵循的原则是<strong>谁创建谁释放</strong>，然而这无法在语言层面上做到约束。对于需要内部释放的资源，如果外部主动释放了，则会导致重复释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RM</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Object* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  ~RM() &#123; <span class="comment">/* destruct all Object */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">RM rm;</span><br><span class="line">Object* o = rm.get(); </span><br><span class="line"><span class="keyword">delete</span> o; <span class="comment">/* error */</span></span><br></pre></td></tr></table></figure><p>对于智能指针来说，资源释放都是通过自动垃圾回收机制。使用该dll资源的用户无需关注是否需要释放资源。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>智能指针有利有弊，最严重的问题是延长了对象的生命期。如果不采取特殊的做法，很难保证对象在我们想要析构的地方析构。同时，由于引入了引用计数，会增加拷贝的开销。</p><h3 id="延长对象生命期"><a href="#延长对象生命期" class="headerlink" title="延长对象生命期"></a>延长对象生命期</h3><p>由于智能指针<em>std::shared_ptr</em>延长了对象的生命期，所以在使用智能指针时需要明确一件事：在我们希望对象析构后，继续使用该对象没有副作用，否则必须要保证对象在我们想要析构时被析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt;&gt; objects;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">create</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; po = <span class="built_in">std</span>::make_shared&lt;Object&gt;();</span><br><span class="line">  objects.emplace(index, po);</span><br><span class="line">  <span class="keyword">return</span> po;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  objects.erase(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="keyword">auto</span> po = create(<span class="number">1</span>);</span><br><span class="line">po-&gt;doSomething(); <span class="comment">/* make sure handle po is acceptable after try to destroy po */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line">destroy(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>另一方面，我们无法确定对象在何地析构，也就意味着对象可能在关键线程析构，进而降低了系统的性能。为此，可以用一个单独的线程专门来做析构，通过一个<em>BlockingQueue<std::shared_ptr<void >&gt;</em>把对象析构都转移到那个专用线程中。这种方法的前提就是程序必须要额外开启一条线程。</p><h3 id="增加拷贝开销"><a href="#增加拷贝开销" class="headerlink" title="增加拷贝开销"></a>增加拷贝开销</h3><p>智能指针的拷贝相对于裸指针多了引用计数的操作，同时可能还会加锁。所以会增加系统开销。大多数拷贝操作发生在传参，因此推荐使用引用传参方式来替换值传参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; &amp;po)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>智能指针使用过程中难免会遇到一些坑点。本节记录一些注意事项，避免低级失误。</p><h3 id="unique-ptr初始化"><a href="#unique-ptr初始化" class="headerlink" title="unique_ptr初始化"></a>unique_ptr初始化</h3><p><em>std::unique_ptr</em>不支持拷贝和赋值。为<em>std::unique_ptr</em>赋初始值有两种方式：<em>new</em>操作和<em>std::make_unique</em>操作。使用这两种方式时都有需要注意的地方：</p><ul><li><em>std::unique_ptr</em>单参数版本的构造函数是<em>explicit</em>，所以不能使用<em>=</em>赋值；</li><li><em>std::make_unique</em>操作是C++14新特性，在某些编译器上是不支持的，在跨平台应用中使用该操作，需要确认是否所有平台都支持该操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up = <span class="keyword">new</span> Object(<span class="number">1</span>); <span class="comment">/* error */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Object(<span class="number">1</span>))</span></span>;  <span class="comment">/* ok     */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; up = <span class="built_in">std</span>::make_unique&lt;Object&gt;(<span class="number">1</span>); <span class="comment">/* ok when compiler support */</span></span><br></pre></td></tr></table></figure><h3 id="unique-ptr陷阱"><a href="#unique-ptr陷阱" class="headerlink" title="unique_ptr陷阱"></a>unique_ptr陷阱</h3><p>尽量不要将<em>std::unique_ptr</em>和裸指针混用。如果二者混用，会导致资源管理混乱，同时很有可能导致程序奔溃，内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object *b = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; uo1, uo2;</span><br><span class="line">uo1.reset(b);</span><br><span class="line">uo2.reset(b); <span class="comment">/* uo1和uo2将指向同一个位置 */</span></span><br></pre></td></tr></table></figure><p><em>release</em>操作并不会释放对象的内存，其仅仅是返回一个指向被管理对象的指针，并释放<em>std::unique_ptr</em>的所有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; uo = <span class="built_in">std</span>::make_unique&lt;Object&gt;();</span><br><span class="line">Object* o = uo.release();</span><br><span class="line"><span class="keyword">delete</span> o;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr陷阱"><a href="#shared-ptr陷阱" class="headerlink" title="shared_ptr陷阱"></a>shared_ptr陷阱</h3><p>尽量不要通过<em>std::shared_ptr</em>智能指针的<em>get</em>操作获取其指向对象的裸指针。一方面智能指针析构时其变成了空悬指针，另一方面如果不小心<em>delete</em>了裸指针，那么智能指针将会<em>ACCESS VIOLATION</em>。同时，如果你把获取的裸指针继续赋给智能指针的话，又将是一个严重的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; so = <span class="keyword">new</span> Object();</span><br><span class="line">Object *o = so.get();</span><br><span class="line"><span class="keyword">delete</span> o;</span><br><span class="line">so-&gt;doSomething(); <span class="comment">/* access violation */</span></span><br></pre></td></tr></table></figure><p>如果要使用智能指针的裸指针，要确保不能将该指针传递到模块外部，同时传递到内部时，也要保证内部对象在智能指针之前释放。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>挖掘点智能指针实际使用过程中的实践经验。</p><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>当使用<em>std::unique_ptr</em>需要注意异常问题。如下代码的执行顺序并不确定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T), function_may_throw());</span><br></pre></td></tr></table></figure><p>当上述代码的执行顺序为：<em>new T</em>→<em>function_may_throw()</em>→<em>unique_ptr<T>(…)</em>时，当<em>function_may_throw()</em>抛出异常，则会导致内存泄漏。以下写法能够避免内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="built_in">std</span>::make_unique&lt;T&gt;(), function_may_throw());</span><br></pre></td></tr></table></figure><p>在C++17中对参数的执行顺序做了约束：</p><blockquote><p>The initialization of a parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other parameter.</p></blockquote><p>也就意味上面那个不定执行顺序的代码，只可能有两种执行顺序：</p><ul><li>顺序一：<em>new T</em>→<em>unique_ptr<T>(…)</em>→<em>function_may_throw()</em></li><li>顺序二：<em>function_may_throw()</em>→<em>new T</em>→<em>unique_ptr<T>(…)</em></li></ul><p>这两种执行顺序都不存在异常安全问题了。不过要求编译器支持C++17。</p><blockquote><p>注意：<em>std::make_shared</em>和<em>std::make_unique</em>都是异常安全的。</p></blockquote><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>对于智能指针，其引用计数增加/减少操作是线程安全的，并且是无锁的。但是其本身并非是线程安全的。因此在多线程访问的情况下，必须要一些同步措施。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; po = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/* thread 1 */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; new_po;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">ScopedLock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">  new_po = po; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thread 2 */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; new_po = <span class="keyword">new</span> Object();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">ScopedLock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">  po = new_po;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占资源"><a href="#独占资源" class="headerlink" title="独占资源"></a>独占资源</h3><p>当我们需要独占某个资源时，尽量使用<em>std::unique_ptr</em>，不要使用<em>std::shared_ptr</em>。这样可以避免<em>std::shared_ptr</em>所面临的生命期延长问题。同时，多个<em>std::shared_ptr</em>可以访问修改同一个对象，这在资源独占时是不可接受的。</p><p><em>std::shared_ptr</em>相对于<em>std::unqiue_ptr</em>资源开销更大，这是因为<em>std::shared_ptr</em>需要维护一个指向动态内存对象的线程安全的引用计数器。因此，资源独占时，首选<em>std::unique_ptr</em>智能指针。</p><h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>RAII，Resource Acquisition Is Initialization，资源获取时就是初始化时。在使用智能指针使尽量避免下面操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object *o = <span class="keyword">new</span> Object;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(o)</span></span>;</span><br></pre></td></tr></table></figure><p>这要使用的缺陷在于：</p><ul><li>无法确保裸指针是否依然有效；</li><li>无法确保裸指针不会被二次赋给智能指针。</li></ul><h3 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h3><p>如果你使用智能指针管理的资源不是<em>new</em>分配的内存，记住传递给它一个删除器。注意使用<em>new []</em>分配的数组，也必须要使用删除器，否则会导致资源泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(<span class="keyword">new</span> Object[<span class="number">10</span>], [](Object *o)&#123;<span class="keyword">delete</span>[]p&#125;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; <span class="title">po</span><span class="params">(<span class="keyword">new</span> Object[<span class="number">10</span>], default_deleter&lt;Object[]&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意，<em>std::unique_ptr</em>是支持管理数组的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object[]) uo(<span class="keyword">new</span> A[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure><p><em>std::unique_ptr</em>的删除器有两种实现方式：函数指针、类对象和lambda表达式。上文已经给出了lambda表达式的写法。下面给出其他两个的例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CConnect</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(CConnect *obj)</span> </span>&#123;</span><br><span class="line">  obj-&gt;disconnect();</span><br><span class="line">  <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">std::unique_ptr&lt;CConnect, decltype(Deleter)*&gt; up(new CConnect, deleter);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deleter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(CConnect *obj)</span> </span>&#123;</span><br><span class="line">    obj-&gt;disconnect();</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::unique_ptr&lt;CConnect, Deleter&gt; up1(new CConnect);</span><br><span class="line">std::unique_ptr&lt;CConnect, Deleter&gt; up2(new CConnect, up1.get_deleter());</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>使用<em>std::shared_ptr</em>时要避免循环引用。这也是<em>std::weak_ptr</em>存在的价值。建议在设计类时，如果不需要资源的所有权，而不要求控制对象的生命期时，使用<em>std::weak_ptr</em>替代<em>std::shared_ptr</em>。<em>std::weak_ptr</em>不存在延长对象生命期的问题。</p><p>循环引用的经典案例为列表，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; _pre;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; _next;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_pre = n1;</span><br></pre></td></tr></table></figure><p>要想打破循环引用，则需要借助<em>std::weak_ptr</em>的力量，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Node&gt; _pre;</span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Node&gt; _next;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_pre = n1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; spn = n2-&gt;_pre.lock();</span><br><span class="line"><span class="keyword">if</span> (spn) &#123;</span><br><span class="line">  spn-&gt;doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://ootips.org/yonat/4dev/smart-pointers.html">Smart Pointers - What, Why, Which?</a></li><li><a href="https://stackoverflow.com/questions/19472550/exception-safety-and-make-unique">Exception safety and make_unique</a></li></ul>]]></content>
    
    
    <summary type="html">智能指针是资源管理的必备神器，掌握智能指针，开发稳定可靠的应用程序。</summary>
    
    
    <content src="http://ww4.sinaimg.cn/large/61b57e82gw1f8obk6993nj21gs0i240q.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Experience" scheme="https://www.freehacker.cn/tags/Experience/"/>
    
    <category term="CPlusPlus" scheme="https://www.freehacker.cn/tags/CPlusPlus/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC-GCC两种实现方案对比</title>
    <link href="https://www.freehacker.cn/comm/tcc-vs-gcc/"/>
    <id>https://www.freehacker.cn/comm/tcc-vs-gcc/</id>
    <published>2018-05-26T00:23:19.000Z</published>
    <updated>2021-02-24T12:00:22.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>越过山丘，才发现无人等候。</p></blockquote><p>WebRTC为了防止网络拥塞结合了Loss-based BWE和Delay-based BWE两种算法，其中Loss-based BWE算法较为复杂。<a id="more"></a>WebRTC中提出了两种方案来处理Loss-based BWE：</p><ul><li>Recv-side Delay-based BWE：REMB-based GCC</li><li>Send-side Delay-based BWE：TransportFB-based GCC</li></ul><p>本文着重于两种方案的不同点，并分析二者的区别，进而确定在实际应用中应该选择哪一种方案。同时本文也会通过仿真结果，来给出GCC算法的性能分析。</p><blockquote><p>本文按照其实现机制称：REMB-based GCC为REMB、TransportFB-based GCC为TCC。</p></blockquote><h2 id="BWE-Evolution"><a href="#BWE-Evolution" class="headerlink" title="BWE Evolution"></a>BWE Evolution</h2><p>带宽预估算法的演进经过两个阶段：</p><ul><li>Loss-based BWE</li></ul><ul><li>Delay-based BWE</li></ul><p>Loss-based BWE通过RTCP-RR报文来检测丢包率，然后根据丢包率来调整对应的带宽。Delay-based BWE通过分析包之间的延时来预测拥塞，在路由器丢弃数据包之前尝试降低带宽。</p><p>Loss-based BWE和Delay-based BWE的可行性都是基于网络路由器的特性：</p><ul><li>Loss-based BWE：当网络发生拥塞时，路由器缓冲区被填满，后续的数据包会被丢弃。</li><li>Delay-based BWE：当网络开始出现拥塞时，路由器缓冲区数据逐渐增加，数据包之间的延迟变化加剧。</li></ul><p>相对于Loss-based BWE，Delay-based BWE能够更早的发现网络的拥塞状况，进而提前调整码率，防止拥塞加重。</p><p>因此，在WebRTC中使用Loss-based BWE来适应丢包情况和探测带宽，而使用Delay-based BWE来提前发现网络拥塞，降低队列延迟，提高实时音视频通信的质量。</p><h2 id="Send-side-Delay-based-BWE"><a href="#Send-side-Delay-based-BWE" class="headerlink" title="Send-side Delay-based BWE"></a>Send-side Delay-based BWE</h2><p><img src="../../assets/comm/gcc-tcc.png" alt=""></p><p>Transport-CC将接收端的延迟信息通过RTCP-TCC反馈给发送端，然后在发送端进行Delay-based BWE。WebRTC通过以下两步来实现该方案：</p><ul><li><strong>Transport wide sequence numbers header extension</strong></li></ul><p>x所有的RTP包额外的增加一个头部扩展项，该扩展项用来表示发送序列号。通过SDP来协商是否打开该扩展项：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br></pre></td></tr></table></figure><ul><li><strong>Transport Feedback</strong></li></ul><p>接收方向媒体发送方定期发送反馈，提供有关接收到的数据包的信息以及它们之间的延迟。反馈信息通过RTCP-Transport-FB反馈给发送端。通过SDP来协商是否启用：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=rtcp-fb:100 transport-cc </span><br></pre></td></tr></table></figure><p>RTCP-Transport-FB默认发送频率1time/100ms，同时其动态适应使用5％的可用带宽，最大频率值为1time/50ms、最小频率值为1time/250ms。以1time/100ms的频率发送，其最大需要耗费16kbps带宽。</p><p><img src="../../assets/comm/gcc-tcc-frequency.png" alt=""></p><h2 id="Recv-side-Delay-based-BWE"><a href="#Recv-side-Delay-based-BWE" class="headerlink" title="Recv-side Delay-based BWE"></a>Recv-side Delay-based BWE</h2><p><img src="../../assets/comm/gcc-remb.png" alt=""></p><p>Recv-side Delay-based BWE在接收端计算预估码率结果，并通过RTCP-REMB反馈给发送端。实现Recv-side Delay-based BWE需要两步：</p><ul><li><strong>Transport with Absolute Send Time</strong></li></ul><p>绝对发送时间用于表示发送端发送该包的时间，在RTP报头的扩展中发送。需要在SDP中协商是否启用该扩展：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br></pre></td></tr></table></figure><ul><li><strong>REMB Feedback</strong></li></ul><p>接收端通过RTCP-REMB反馈预估的码率值，需要在SDP中协商是否启动该反馈：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=rtcp-fb:&lt;payload type&gt; goog-remb</span><br></pre></td></tr></table></figure><p>在REMB方案中，其他厂商也给出了一些优化思路：</p><ul><li>WebRTC Gateway反馈的REMB码率结果需要综合考虑同一个会议中其他用户的下行带宽和丢包。</li><li>在REMB方案中引入TCC方案中的一些优点，譬如线性滤波器。</li></ul><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><p>WebRTC实现了两种滤波器来进行延迟增长趋势的评估。Send-side Delay-based BWE采用Trendline Filter，而Recv-side Delay-based BWE采用了Kalman Filter。</p><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p>暂未发现效果对比的论文或博客，后续会自行研究对比。</p><h3 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h3><p>TCC的优点在于无需依赖于两个端点——方便BWE算法测试，更易改进算法。发送端知道其使用了何种算法，进而按照场景的不同，切换BEW算法。来自Google Group的讨论：</p><blockquote><ul><li>Easier to roll out improvements if the logic is located on one side and the other side is kept dumb.</li><li>Having the logic on the send-side means you know more about what has been sent. For instance, you know if the source is very bursty (screencasts) which can help us make better decisions.</li></ul></blockquote><p>TCC的缺点在于浪费了一定的带宽，同时Firefox目前还不支持TCC。</p><p>REMB的优点在于码率的控制权在服务端（接收端），没有额外的带宽浪费。</p><p>REMB的缺点在于调试起来不方便，需要同时关注两个端，同时WebRTC已经不对REMB提供支持——这意味着当下的REMB实现版本可能存在不少BUG，同时BWE的新特性也不会加入到当前的REMB实现。</p><blockquote><p>Google从Chrome55开始支持Send-side Delay-based BWE。查了下WebRTC的代码提交，REMB方案几乎没有实质性修改，而TCC针对性做了优化。</p></blockquote><p>在采用TCC方案后，接收也可以利用REMB来通知发送端码率发送上限。</p><h3 id="Which-One"><a href="#Which-One" class="headerlink" title="Which One?"></a>Which One?</h3><p>从优缺点可以明显的看出，我们应该选择TCC。但这里还是要结合场景，如果服务端对码率的控制权十分重要，还是有必要使用REMB的，只是后续的BUG只能自己解了。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>TCC和GCC本质上都是使用了GCC算法。GCC算法的设计目的是为了达到：</p><ul><li>最大化利用可利用的带宽</li><li>带宽瓶颈时能够公平共享带宽（TCP流、GCC流）</li><li>最小化队列延迟</li></ul><p>本节引用了多篇研究论文的结果，试图挖掘GCC方案的性能优点和漏洞。其中一些变量的含义如下：</p><blockquote><p>Channel Utilization：$U = R/b$，R为预估码率</p><p>Good Channel Utilization：$G = v/b$，v为rtp发送码率</p><p>Loss Ratio：$l=(lost_bytes)/(received_bytes)$</p><p>Number of Delay-based Decrease Events：$n_{dd}$，降低码率的REMB包数量</p></blockquote><h3 id="Single-GCC-Flow-with-Constant-Avaliable-Bandwidth"><a href="#Single-GCC-Flow-with-Constant-Avaliable-Bandwidth" class="headerlink" title="Single GCC Flow with Constant Avaliable Bandwidth"></a>Single GCC Flow with Constant Avaliable Bandwidth</h3><p>设置$RTT_{m}=50ms$，可利用带宽为$b(t)=2000kbps$，仿真结果如下：</p><p><img src="../../assets/comm/gcc-single-gcc-flow.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>GCC预估码率从300kbps上升到2000kbps需要30s左右</li><li>GCC预估码率在带宽阈值时波动严重，波动幅值最大可达1000Mpbs</li><li>GCC预估码率会经常超过带宽阈值进而导致严重丢包</li><li>GCC出现严重带宽时会大大提高FEC的比例，最大可达50%</li><li>当码率接近带宽上限时，RTT增大导致REMB发送频率增加，进而降低码率</li></ul><p>设置$RTT<em>{m, j} \in \left { 30, 50, 80, 120 \right }ms$，可利用带宽$b</em>{i} \in \left { 500, 1000, 1500, 2000 \right }kbps$，仿真结果如下：</p><p><img src="../../assets/comm/gcc-single-gcc-flow-multi-bandwidth-and-delay.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>信道利用率几乎不受带宽和延迟影响，维持在80%左右</li><li>丢包率并不受RTR变化的影响，丢包率随着带宽的增加而增加，最高达到2.8%</li><li>随着带宽的增加，丢包率随着增加，进而导致FEC的比例逐步增加，最高达到20%</li><li>采用GCC算法后，队列延迟中位数近似于0，90%样本值小于0.25m</li></ul><h3 id="Single-GCC-Flow-with-Variable-Available-Bandwidth"><a href="#Single-GCC-Flow-with-Variable-Available-Bandwidth" class="headerlink" title="Single GCC Flow with Variable Available Bandwidth"></a>Single GCC Flow with Variable Available Bandwidth</h3><p>设置$RTT<em>{m}=50ms$，可利用带宽先阶梯递增后阶梯递减，增减可选值为$b</em>{i} \in \left { 500, 1000, 1500, 2000 \right }kbps$，仿真结果如下：</p><p><img src="../../assets/comm/gcc-single-gcc-flow-step-bandwidth.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>随着码率阶梯递增或递减，GCC预估码率能够随之快速递增递减</li><li>码率增长到较高码率时，码率波动明显增加，FEC比例随着增加</li><li>码率从高位下降时，瞬间丢包率增加，会导致发送端码率严重下降，远低于接收端预估码率</li></ul><h3 id="Multiple-GCC-Flow"><a href="#Multiple-GCC-Flow" class="headerlink" title="Multiple GCC Flow"></a>Multiple GCC Flow</h3><p>设置$RTT<em>{m}=50ms$，可利用带宽$b</em>{i}  = 1000kbps$，仿真结果如下：</p><p><img src="../../assets/comm/gcc-multiple-gcc.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>两个GCC流之间的码率竞争呈现无规律性</li></ul><p><img src="../../assets/comm/gcc-multiple-gcc-channel.png" alt=""></p><p>从上图可以看出：</p><ul><li>在1000kbps和2000kbps时，码率分配十分不公平</li><li>在3000kbps时，码率分配相对公平，但先启动的GCC流仍然分配较多的码率</li></ul><h3 id="Single-GCC-Flow-and-Single-TCP-Flow"><a href="#Single-GCC-Flow-and-Single-TCP-Flow" class="headerlink" title="Single GCC Flow and Single TCP Flow"></a>Single GCC Flow and Single TCP Flow</h3><p>设置$RTT<em>{m}=50ms$，可利用带宽$b</em>{i}  = \left { 1000, 2000, 3000 \right }kbps$，考虑两种场景：先启动GCC流，100s后启动TCP流、先启动TCP流，100s后启动GCC流，仿真结果如下：</p><p><img src="../../assets/comm/gcc-single-gcc-and-single-tcp.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>GCC流的信道利用率随着带宽的增加而增加，且普遍低于TCP流的带宽占用率</li><li>GCC流后启动能够帮助GCC流获取到更高的带宽占用率</li></ul><p>将先启动TCP流后启动GCC流这种场景抽出来分析，考虑可利用带宽为$b(t)=1000kbps$和$b(t)=3000kbps$两种情况，仿真结果如下：</p><p><img src="../../assets/comm/gcc-single-gcc-and-single-tcp-detail.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>在较低带宽时，GCC流会出现饥饿现象，无法上升到较高的码率</li><li>GCC流启动后一开始能够和TCP公平分配带宽，后续一直收到REMB包进而限制了带宽上升</li><li>若没有REMB包的影响，GCC流的带宽增长会比TCP流更加激进（图b）</li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>GCC算法能够较好的处理单个GCC流，但是一旦和其他GCC流或TCP流共存时，GCC算法无法提供公平的带宽分配。</p><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>如何解决与TCP流共存时的饥饿问题是后续的优化关键。有研究表明：GCC流与TCP流共存时的饥饿问题，是由于GCC算法的自适应门限机制导致的。</p><p>当GCC算法采用较小的阈值时，Delay-based BWE优于Loss-based BWE。然而当GCC流和TCP流码率达到瓶颈时，较小的阈值会导致GCC流出现饥饿问题。</p><p><img src="../../assets/comm/gcc-single-gcc-and-single-tcp-starvation.png" alt=""></p><p>下图给出了自适应门限值对单个GCC流的影响：</p><p><img src="../../assets/comm/gcc-single-gcc-flow-threshold.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>随着门限值的增加，$n<em>{dd}$数量减少，这是因为较大的门限值，导致在不触发<strong>OVERUSE</strong>信号的情况下，允许更大的$m(t</em>{i})$变化。</li><li>随着门限值的增加，GCC算法偏向于Loss-based BWE，进而带宽占用率逐渐增加，其后果是更大的丢包率和队列延迟。</li><li>随着带宽的增加，带宽占用率逐渐增加，Delay-based-Decrease REMB逐渐减少，队列延时逐渐减小。</li></ul><p>从上图中展示Loss信息的图标，可以看出带宽的增加会导致更大的丢包率，这是为何？假设队列大小为$q(t)$，带宽为$b(t)$，那么我们可以将队列延迟抽象为如下模型：</p><script type="math/tex; mode=display">T_{q}(t) = \frac{q(t)}{b(t)}</script><p>当$b(t)$较小时，譬如500kbps，那么队列延迟变化变大；当$b(t)$较大时，譬如2000kbps，那么队列延迟变化变小。因此对于较高带宽，Delay-based-Decrease REMB较少，而对于较低带宽，Delay-based-Decrease REMB较多。当带宽较高时，以Loss-based BWE为主，带宽的调整主要是依据丢包信息，因此此时势必会触发更高的丢包率。</p><p><img src="../../assets/comm/gcc-single-gcc-flow-queue-delay.png" alt=""></p><p>下图给出了自适应门限值对GCC流和TCP流并发时的影响：</p><p><img src="../../assets/comm/gcc-single-gcc-and-single-tcp-influence.png" alt=""></p><p>从仿真结果可以看出：</p><ul><li>随着门限值的增加，GCC流的带宽占用率逐步增加</li><li>随着门限值的增加，$n<em>{dd}$数量减少，相对于单个GCC流，此时的$n</em>{dd}$数量不在一个数量级</li></ul><p>对比单GCC流和并发GCC/TCP流可以看出：</p><ul><li>当单GCC流时，较小的门限值能够提供更好的带宽占用率，同时维持较低的丢包率和延迟</li><li>当并发GCC/TCP流时，较小的门限值会导致Delay-based BWE占主导地位，进而导致GCC流饥饿。</li></ul><p>因此针对于不同的场景，我们必须要针对性的调整门限值。</p><p>本节主要分析了TCP流和GCC共存时的饥饿问题，两个GCC流共存时的无规律性也需要进一步研究。现阶段未找到相关资料，后续深入后继续撰写。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01">RTP Extensions for Transport-wide Congestion Control draft-holmer-rmcat-transport-wide-cc-extensions-01</a></li><li><a href="http://www.rtcbits.com/2017/01/bandwidth-estimation-in-webrtc-and-new.html">Bandwidth Estimation in WebRTC (and the new Sender Side BWE)</a></li><li><a href="https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-03">A Google Congestion Control Algorithm for Real-Time Communication draft-ietf-rmcat-gcc-03</a></li><li><a href="https://c3lab.poliba.it/MultimediaCC">Congestion Control for Real-time Communication</a></li><li><a href="http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf">Analysis and Design of the Google Congestion Control for Web Real-time Communication (WebRTC)</a></li><li><a href="https://c3lab.poliba.it/images/d/d2/Skype_wwic07.pdf">An Experimental Investigation of the Congestion Control Used by Skype VoIP</a></li><li><a href="https://www.researchgate.net/publication/260200748_Understanding_the_Dynamic_Behaviour_of_the_Google_Congestion_Control_for_RTCWeb">Understanding the Dynamic Behaviour of the Google Congestion Control for RTCWeb</a></li><li><a href="http://conferences.sigcomm.org/sigcomm/2013/papers/fhmn/p21.pdf">Experimental Investigation of the Google Congestion Control for Real-Time Flows</a></li><li><a href="https://www.sciencedirect.com/science/article/pii/S1389128610002914">Skype Video congestion control: An experimental investigation</a></li><li><a href="https://c3lab.poliba.it/images/7/73/Cdc08_slides.pdf">A Mathematical Model of the Skype VoIP Congestion Control Algorithm</a></li><li><a href="http://eeweb.poly.edu/faculty/yongliu/docs/imc12tech.pdf">Video Telephony for End-consumers: Measurement Study of Google+, iChat, and Skype</a></li></ul>]]></content>
    
    
    <summary type="html">从实验仿真的角度，研究GCC算法的优缺点，同时给出TCC和GCC两种实现机制的对比。</summary>
    
    
    <content src="http://wx3.sinaimg.cn/large/61b57e82gy1frofy4yu8dj21gs0i279l.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="WebRTC" scheme="https://www.freehacker.cn/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>五月、阅读、思考、实践、反思</title>
    <link href="https://www.freehacker.cn/reading/read-and-more/"/>
    <id>https://www.freehacker.cn/reading/read-and-more/</id>
    <published>2018-05-03T00:54:05.000Z</published>
    <updated>2020-10-27T04:47:05.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”</p></blockquote><p>最近阅读了几本书，渐渐地培养了自己持续阅读的兴趣。看到公众号老金每月都在一个书单列表。我也整理定期整理下我的书单。<a id="more"></a></p><h2 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h2><p><img src="../../assets/reading/three-body.png" alt=""></p><p>点评：除了早期沉迷的网络小说，三体是我今年来最投入的一本书。不光光是科幻，书中对人性的思考更让人深思。</p><h2 id="学会提问"><a href="#学会提问" class="headerlink" title="学会提问"></a>学会提问</h2><p><img src="../../assets/reading/asking-the-right-questions.png" alt=""></p><p>点评：学会思考，掌握思考的艺术。读完之后，生活中需要思考的地方不在小白。书中内容较多，需多深度阅读，深度思考，反复实践，才能融会贯通。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p><img src="../../assets/reading/refactor.png" alt=""></p><p>点评：一本程序员需要反复阅读的书，之前阅读过其中部分内容，这一次下定决心全部读完。受益匪浅，需要改进的地方还有很多。</p><h2 id="穷爸爸富爸爸"><a href="#穷爸爸富爸爸" class="headerlink" title="穷爸爸富爸爸"></a>穷爸爸富爸爸</h2><p><img src="../../assets/reading/rich-dad-poor-dad.png" alt=""></p><p>点评：给自己多一条出路，能够从容的面对程序员的中年危机。印象最深刻的是：工作不为钱，而为学习某项技能，学习最终产生价值。</p><h2 id="Head-First-设计模式"><a href="#Head-First-设计模式" class="headerlink" title="Head First 设计模式"></a>Head First 设计模式</h2><p><img src="../../assets/reading/head-first-design-pattern.png" alt=""></p><p>点评：一直没有系统的阅读过设计模式的书，这本书寓学于乐，读起来一点不枯燥。其可能的缺点在于不够聚焦，有点啰嗦，进而看了后面忘了前面。</p><h2 id="浪潮之巅"><a href="#浪潮之巅" class="headerlink" title="浪潮之巅"></a>浪潮之巅</h2><p><img src="../../assets/reading/lang-chao-zhi-dian.png" alt=""></p><p>点评：讲述高新科技成败历史的书籍，从本书能够看出一家百年企业应该必须的元素，以及优秀的领导人的重要性。基因决定命运。</p><h2 id="分布式服务框架原理与实践"><a href="#分布式服务框架原理与实践" class="headerlink" title="分布式服务框架原理与实践"></a>分布式服务框架原理与实践</h2><p><img src="../../assets/reading/distributed-structure.png" alt=""></p><p>点评：之前一直做基础开发，对于架构方面了解很少，这本书算是我架构的启蒙书籍。虽然目前的开发中还没有应用到相关知识，相信后续一定有所帮助。</p><h2 id="这样读书就够了"><a href="#这样读书就够了" class="headerlink" title="这样读书就够了"></a>这样读书就够了</h2><p><img src="../../assets/reading/zhe-yang-du-shu-jiu-gou-le.png" alt=""></p><p>点评：拆书帮的经典之作，对于致用类图书的阅读有很大的启发作用。不过这种读书方法最好还是现场读书。对于一个人读书，这本书也告诉我们一个道理：学到就是赚到，不必强求掌握所有。</p><h2 id="把时间当作朋友"><a href="#把时间当作朋友" class="headerlink" title="把时间当作朋友"></a>把时间当作朋友</h2><p><img src="../../assets/reading/ba-shi-jian-dang-zuo-peng-you.png" alt=""></p><p>点评：李笑来的力作，对我影响很大的一本书，这本书是真正的提升了我个人的内驱力。似乎是忽然，我从曾经的懒散，变得自律。</p><h2 id="高效能人士的七个习惯"><a href="#高效能人士的七个习惯" class="headerlink" title="高效能人士的七个习惯"></a>高效能人士的七个习惯</h2><p><img src="../../assets/reading/the-seven-habits-of-highly-effective-people.png" alt=""></p><p>点评：一本常读常新的书，以前对成功学嗤之以鼻，从这本书后对其有了改观。这本书也反映了我阅读方面的一个问题——读了就忘。因此，我自己开始从宏观的角度来记录所读所思。</p><h2 id="禅与摩托车维修艺"><a href="#禅与摩托车维修艺" class="headerlink" title="禅与摩托车维修艺"></a>禅与摩托车维修艺</h2><p><img src="../../assets/reading/zen-and-the-art-of-motocyle-maintanance.png" alt=""></p><p>点评：因为对摩托车感兴趣而看这本书，尚未看完，也不确定以后会不会看完。当作者开始反复的想出去阐述良质这个概念的时候，我开始对其丧失了兴趣。有可能现在的觉悟不够。</p>]]></content>
    
    
    <summary type="html">阅读、思考、实践、反思</summary>
    
    
    <content src="http://wx2.sinaimg.cn/large/61b57e82gy1fqyfihxtm9j21gs0i2421.jpg" type="image"/>
    
    
    <category term="Reading" scheme="https://www.freehacker.cn/categories/Reading/"/>
    
    
    <category term="Book" scheme="https://www.freehacker.cn/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>低概率问题分析解决</title>
    <link href="https://www.freehacker.cn/advanced/low-probability-analysis/"/>
    <id>https://www.freehacker.cn/advanced/low-probability-analysis/</id>
    <published>2018-03-14T00:32:59.000Z</published>
    <updated>2020-10-27T04:47:05.346Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发过程中，经常会遇到出现概率很低，但只要出现了就会对系统可用性影响很大的问题。这类问题总是在JIRA上被挂起，时不时的在测试中被报出来。不解决是永不歇停的。因此，在这里根据我遇到的各种低概率问题，整理出一套解决问题的方法，希望在解决其他低概率问题时能够有些借鉴。<a id="more"></a></p><h2 id="明确问题现象"><a href="#明确问题现象" class="headerlink" title="明确问题现象"></a>明确问题现象</h2><p>明确问题现象对于解决分析问题有很大的帮助。有时候，我们看到的现象只是表面的，或者只是具体现象的某一部分。以视频会议为例，当出现视频画面卡顿，如果我们只关注这一现象，很有可能认为是丢包了。但卡顿这个现象和更多的细节有关：</p><ul><li>卡顿周期：是一直卡顿还是周期性出现卡顿，卡顿周期是多少？</li><li>是否丢包：丢包率是多少？是否持续丢包？</li><li>卡顿发生时间：是白天还是晚上？是工作日还是周末？</li></ul><p>越多的信息能够更好地帮助我们分析问题，不要急于下定论。低概率问题也存在出现的时候，出现时首先要仔细观察，明确问题现象。由于低概率问题出现概率很低，这次观察的结果至关重要。</p><p>这里需要谨记：我们要关注哪些现象与我们具体的业务有关。因此利用自己的经验，但不要局限于现存的经验，开阔的思维有利于问题的解决。</p><h2 id="引入分析工具"><a href="#引入分析工具" class="headerlink" title="引入分析工具"></a>引入分析工具</h2><p>团队在项目一开始就要制订潜在的问题分析工具开发计划。分析工具能够帮我们定位深层次的现象，并将干扰现象排除在分析之外。一般情况下，团队需要哪些工具帮助分析是很好规划的。工具可能是产品软件的自带功能，也可以是第三方或者自研的小工具。在我们视频会议团队，存在如下分析工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">分析工具--&gt;第三方</span><br><span class="line">第三方--&gt;Wireshark</span><br><span class="line">第三方--&gt;IPerf3.0</span><br><span class="line">第三方--&gt;SocketTools</span><br><span class="line">第三方--&gt;Elecard-StreamEye-Tools</span><br><span class="line">第三方--&gt;YUVPlayer</span><br><span class="line">第三方--&gt;MFTools</span><br><span class="line">第三方--&gt;Network-Emulator-Toolkit</span><br><span class="line">分析工具--&gt;自研</span><br><span class="line">自研--&gt;音频分析小工具</span><br><span class="line">自研--&gt;视频分析小工具</span><br><span class="line">自研--&gt;音视频数据Dump</span><br><span class="line">自研--&gt;日志分析工具</span><br><span class="line">自研--&gt;煲鸡功能</span><br><span class="line">自研--&gt;性能测试小工具</span><br></pre></td></tr></table></figure><p>如果因为缺少分析工具，而导致存在的问题迟迟不得解决，或是解决迟缓。开发人员自己需要反思。针对于视频卡顿问题，在发现时我们利用了两个工具：视频分析小工具和Wireshark。通过WireShark我们定位到当前网络没有丢包。通过视频分析小工具我们定位到问题出现在接收端。现在我们能够确定的当前现象是：</p><ul><li>视频卡顿</li><li>网络无丢包</li><li>周期性卡顿</li><li>夜晚发生</li></ul><h2 id="分析问题现象"><a href="#分析问题现象" class="headerlink" title="分析问题现象"></a>分析问题现象</h2><p>不要急着去看代码。先分析可能导致这个现象的原因，并根据各种可能原因做好准备。力求一旦下次出现，一次性定位问题。上面的例子总体现象是卡顿，包含了三个细节内容，针对现象和细节部分做针对性分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">卡顿问题--&gt;卡顿现象</span><br><span class="line">卡顿现象--&gt;采集&#x2F;预处理&#x2F;编码&#x2F;发送</span><br><span class="line">采集&#x2F;预处理&#x2F;编码&#x2F;发送--&gt;排除</span><br><span class="line">卡顿现象--&gt;网络波动</span><br><span class="line">卡顿现象--&gt;接收</span><br><span class="line">卡顿现象--&gt;解码</span><br><span class="line">卡顿现象--&gt;处理</span><br><span class="line">卡顿现象--&gt;渲染</span><br><span class="line">卡顿问题--&gt;周期性卡顿</span><br><span class="line">周期性卡顿--&gt;周期性网络波动</span><br><span class="line">周期性卡顿--&gt;代码周期性丢包</span><br><span class="line">卡顿问题--&gt;无丢包</span><br><span class="line">无丢包--&gt;排除网络丢包因素</span><br><span class="line">无丢包--&gt;网络抖动</span><br><span class="line">卡顿问题--&gt;夜晚发生</span><br><span class="line">夜晚发生--&gt;网络因素影响</span><br></pre></td></tr></table></figure><p>现象分析可能会引入一系列可能原因，先将所有可能的原因罗列出来，然后逐项排查。无法排除的就是我们分析的关键。对问题正确的分析，能够帮助我们少走很多弯路，这个需要耐心。</p><h2 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h2><p>对于问题现象一定存在着一条调用链，这个调用链中某一个链条出错，进而导致问题发生。通过调用链分析，我们能够更深层次的理解这个问题的可能原因，并且有可能在分析过程中就找打了问题的根源。</p><p>对于调用链简单的问题，可以直接评审代码，尝试找到问题。但是对于调用链很复杂，涉及很多模块，直接评审代码就和大海捞针一样。此时需要做的是熟悉核心调用步骤。如果代码是自己开发的，只要时间不长大多都熟悉，但是如果是长时间未维护或者是第三方代码，熟悉核心调用步骤就极为重要。</p><p>针对视频卡顿场景，需要熟悉的调用链步骤包含：RTP接收、RTP组帧、视频解码、视频处理、视频渲染。</p><h2 id="潜在原因埋点"><a href="#潜在原因埋点" class="headerlink" title="潜在原因埋点"></a>潜在原因埋点</h2><p>调用链分析无法找到原因时，就需要进行潜在原因埋点。埋点通常是通过日志和数据上报。埋点要注意粒度、频度和准确度问题。</p><ul><li>粒度：调用链核心步骤</li><li>频度：不影响正常数据分析</li><li>准确度：埋点信息要全面，埋点位置合理</li></ul><p>针对视频卡顿场景，最终埋点的地方为：RTP接收出口、RTP组帧出口、视频解码出口、视频处理出口、视频渲染出口。</p><h2 id="煲鸡压力测试"><a href="#煲鸡压力测试" class="headerlink" title="煲鸡压力测试"></a>煲鸡压力测试</h2><p>低概率问题其核心表现在于出现概率低。要突破概率限制，有两个办法：增加尝试次数和增加并发。两个方法的具体表现为：煲鸡测试和压力测试。对于压力测试，使用压力测试工具，增加大并发；对于煲鸡测试，利用煲鸡小工具，增加尝试次数。</p><p>压力测试和煲鸡测试都要考虑环境问题。这个环境是根据问题现象的推导出来的。针对视频卡顿问题，有一个现象是<strong>夜晚发生</strong>，意味着可能网络并不差。因此我们在煲鸡测试时，特定针对这一现象，在周末过来煲鸡复现。</p><p>煲鸡是个拼耐心的过程，有些问题是可以通过其他手段监控提醒，有些问题是需要时刻盯着，否则转瞬即逝，还有一些问题是需要我们反复操作，记住操作步骤。</p><h2 id="定位解决问题"><a href="#定位解决问题" class="headerlink" title="定位解决问题"></a>定位解决问题</h2><p>等煲鸡测试复现该问题。可能很多次才会复现一次。上面的所有手段也无法保证我们一次解决问题。但也为我们向解决问题迈了一大步。如果经过一次复现，通过埋点数据，一次性解决问题皆大欢喜。如果不能解决，埋点数据能够为我们进一步分析问题。如果上次埋点的数据对你一点用都没有，这个时候就要好好反思。大多数情况下，埋点的数据会给我提供更多的思路。这个时候，可以通过评审代码，或者增加核心埋点数据，争取下次一次性解决问题。</p><div id="flowchart-0" class="flow-chart"></div><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>问题解决了，这个时候就要用手术刀来剖析自己了。剖析分为三点：</p><ul><li>解决问题是否优雅</li><li>问题根源分析</li><li>潜在问题排查</li><li>后续问题避免</li></ul><h2 id="低概率问题处理流程"><a href="#低概率问题处理流程" class="headerlink" title="低概率问题处理流程"></a>低概率问题处理流程</h2><p>有些低概率问题就出现了一次，后续再也没出现，需要执行一定的流程。这个流程需要和测试人员共同制定。一个简单的流程如下：</p><div id="flowchart-1" class="flow-chart"></div><h2 id="虚心接受批评和指导"><a href="#虚心接受批评和指导" class="headerlink" title="虚心接受批评和指导"></a>虚心接受批评和指导</h2><p>解决问题的过程一定不是一帆风顺的，不要妄下定论，保持耐心，开阔思路。对于外界的批评和指导都要需求接收。很多时候自以为是会让我们忽略一些问题，拒绝指导又会让我们难以解决一些问题。成长的机会白白浪费，问题还得不到解决。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始op1=>operation: 发掘现象op2=>operation: 求助工具op3=>operation: 深挖分析op4=>operation: 调用链分析op5=>operation: 原因埋点op6=>operation: 煲鸡压测cond=>condition: 定位解决e=>end: 结束st->op1->op2->op3->op4->op5->condcond(yes)->econd(no)->op3</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始op1=>operation: 指定开发人员op2=>operation: 尝试分析解决cond1=>condition: 是否定位问题op3=>operation: 解决问题op4=>operation: 当前版本煲鸡一定次数cond2=>condition: 是否复现op5=>operation: 降低优先级op6=>operation: 下个版本煲鸡一定次数cond3=>condition: 是否复现op7=>operation: 问题挂起op8=>operation: 最终评审e=>end: 结束st->op1->op2->cond1cond1(yes,right)->op3cond1(no)->op4->cond2cond2(yes,right)->op2cond2(no)->op5->op6->cond3cond3(yes,right)->op3->econd3(no)->op7->op8->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>]]></content>
    
    
    <summary type="html">低概率问题剖析解决方案</summary>
    
    
    <content src="http://wx3.sinaimg.cn/large/61b57e82gy1fpclodaaxoj21hc0gon6r.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Experience" scheme="https://www.freehacker.cn/tags/Experience/"/>
    
  </entry>
  
  <entry>
    <title>三月——迟来的总结和反思</title>
    <link href="https://www.freehacker.cn/republic/2017-improve/"/>
    <id>https://www.freehacker.cn/republic/2017-improve/</id>
    <published>2018-03-03T14:52:22.000Z</published>
    <updated>2020-10-27T04:47:05.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾十有五而志于学,<em>三十而立</em>,<em>四十</em>而<em>不惑</em>,<em>五十</em>而<em>知天命</em>,<em>六十</em>而<em>耳顺</em>,七十而从心所欲不逾矩。</p></blockquote><p>看似繁忙的日子，充满了战术上的偷懒，仍然没有找到适合自己的那套方法论。<a id="more"></a>想把一些东西刻在骨头上，然而这不仅需要时间的帮助，还需要强大的意志力。想完全按照自己的想法和规划来行事，其难度远超制定想法和规划时所能想到的。</p><p>过去的一年，工作、学习、读书、生活，都未能达到开始期望的目标。虽然有一定的进步，但离走出沼泽泥泞还有很远的一段路。坚信人生存在一些壁障，没穿过一个壁障都能发现全新的世界，我离最近的壁障越来越近了。似乎只需要踏出一步，就能越过他，可惜这一步很难跨过。以前一直想借助外力，总希望发生点什么来让我顿悟。却不知道，最终一切都要靠自己的内驱力。形成正向激励，做好以前偷懒不愿做的事，现在的我的内驱力也越来越强。只是，离想要的还是很远。是不是成长，提升了自己对自己的要求？</p><p>令行禁止，是否要成长为有灵魂的机器人？什么时候能够不害怕死去？人生是否是一场赌注，掷骰子的那个人是不是我自己？</p><p>突破自己，走出舒适区，做以前不敢做的事，给自己画一个大饼，然后忘记生活的苟且。树立正确的金钱观、家庭观和工作观。金钱为我所用，家庭为我所托，工作为我所梦。从现在起，阅读、思考、成长，做条有梦想的咸鱼。</p>]]></content>
    
    
    <summary type="html">三省吾身</summary>
    
    
    <content src="http://wx2.sinaimg.cn/large/61b57e82gy1fp01j6z7tsj21hc0i2aip.jpg" type="image"/>
    
    
    <category term="TimeCapsule" scheme="https://www.freehacker.cn/categories/TimeCapsule/"/>
    
    
  </entry>
  
  <entry>
    <title>WebRTC帧率调整策略</title>
    <link href="https://www.freehacker.cn/comm/webrtc-frame/"/>
    <id>https://www.freehacker.cn/comm/webrtc-frame/</id>
    <published>2017-12-09T04:36:45.000Z</published>
    <updated>2021-02-24T12:00:03.629Z</updated>
    
    <content type="html"><![CDATA[<p>与实时视频相关参数包含：帧率、码率、时延、抖动等。帧率体现了视频的流畅性，要想达到较好的流畅性体验要求——网络视频帧率不低于24帧，视频会议帧率不低于15帧。在实际开发中，我们遇到了不少问题<a id="more"></a>，主要包括：</p><ul><li>发送端帧率较低</li><li>接收端帧率较低</li><li>帧率波动较大</li></ul><p>本文主要研究WebRTC中的帧率调整策略，解决上述实际开发中帧率较低的问题，以期达到较好的流畅性体验。</p><h2 id="帧率计算方法"><a href="#帧率计算方法" class="headerlink" title="帧率计算方法"></a>帧率计算方法</h2><p>帧率并非恒定值，帧率大小反映的是每秒多少视频帧的统计值。在视频会议中，同一路视频流发送端的帧率和接收端的帧率并不相同。对于发送端帧率，我们需要明确：<strong>发送端输出帧率不等于摄像头采集帧率，编码器实际输入帧率不等于摄像头采集帧率，发送端帧率为编码器输出帧率</strong>。</p><h3 id="发送端帧率"><a href="#发送端帧率" class="headerlink" title="发送端帧率"></a>发送端帧率</h3><p>摄像头采集帧率决定了发送端输入帧率的最大值。当采集的视频数据传送到编码器时，受制于编码器性能和系统硬件性能，编码器的实际输入帧率并不等于摄像头的采集帧率。摄像头采集帧率和编码器输入帧率共同决定了发送端的帧率。在WebRTC中的统计信息展现的是摄像头的采集帧率（作为输入帧率）和编码器的输出帧率（作为输出帧率）。</p><p><strong>1、发送端输入帧率计算</strong></p><p>WebRTC在<em>“webrtc/video/vie_encoder.cc”</em>文件<strong>EncodeTask</strong>类中统计了摄像头的采集帧率——发送端输入帧率：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  vie_encoder_-&gt;stats_proxy_-&gt;OnIncomingFrame(frame_.width(),frame_.height());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、编码器输入帧率计算</strong></p><p>为了计算编码器的实际输入帧率，WebRTC维持了一个大小为$kFrameCountHistorySize$的数组$T_f$，该数组用于保存最新的$kFrameCountHistorySize$个帧放入数组的时间戳信息。帧率计算$fps$公式如下：</p><script type="math/tex; mode=display">fps=\frac{N_f\times 1000.0f}{T_f[0]-T_f[N_f]}  \qquad {N_f:\ max(T_{now}-T_f[N_f])<kFrameHistoryWinMs}</script><p>其中，</p><ul><li>$kFrameCountHistorySize$一般取值为90，$kFrameCountHistorySize$一般取值为2000；</li><li>$N<em>f$是使$N_f:\ max(T</em>{now}-T_f[N_f])&lt;kFrameHistoryWinMs$成立的最大序列号；</li><li>$T<em>{now}$为当前时间，$T_f[0]=T</em>{now}$是数组内newest帧的时间戳，$T_f[kFrameCountHistorySize]$为数组内现存oldest帧的时间戳；</li><li>当$N_f==0$时，不执行该公式，帧率保持上一次计算的结果。</li></ul><p>在WebRTC中，上述公式在<em>“webrtc/modules/video_coding/media_optimization.cc”</em>文件<strong>MediaOptimization</strong>类中实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessIncomingFrameRate</span><span class="params">(<span class="keyword">int64_t</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int32_t</span> num = <span class="number">0</span>, nr_of_frames = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (num = <span class="number">1</span>; num &lt; (kFrameCountHistorySize - <span class="number">1</span>); ++num) &#123;</span><br><span class="line">    <span class="keyword">if</span> (incoming_frame_times_[num] &lt;= <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">/* don&#x27;t use data older than 2 s */</span></span><br><span class="line">        now - incoming_frame_times_[num] &gt; kFrameHistoryWinMs) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nr_of_frames++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> diff =</span><br><span class="line">        incoming_frame_times_[<span class="number">0</span>] - incoming_frame_times_[num - <span class="number">1</span>];</span><br><span class="line">    incoming_frame_rate_ = <span class="number">0.0</span>;  <span class="comment">/* No frame rate estimate available. */</span></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      incoming_frame_rate_ = nr_of_frames * <span class="number">1000.0f</span> / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(diff);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、编码器输出帧率计算</strong></p><p>为了计算编码器的实际输出帧率，WebRTC维护了一个$kBitrateAverageWinMs$时间段内的已编码帧的数组$T_f$，依据下列公式来计算实际码率：</p><script type="math/tex; mode=display">fps=\frac{90000 \times (sizeof(T_f)-1) + \frac{T_{diff}}{2}}{T_{diff}}</script><p>其中，</p><ul><li>$T<em>{diff}=T_f[back]-T_f[front]$，表示数组$T_f$最大的时间间隔，当$T</em>{diff}&lt;0$时，$fps=sizeof(T_f)$；</li><li>$sizeof(T_f)$表示数组$T_f$的大小，当$sizeof(T_f)&lt;=1$时，$fps=sizeof(T_f)$。</li></ul><p>在WebRTC中，上述公式在<em>“webrtc/modules/video_coding/media_optimization.cc”</em>文件<strong>MediaOptimization</strong>类中实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaOptimization::PurgeOldFrameSamples</span><span class="params">(<span class="keyword">int64_t</span> now_ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!encoded_frame_samples_.empty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now_ms - encoded_frame_samples_.front().time_complete_ms &gt;</span><br><span class="line">        kBitrateAverageWinMs) &#123;</span><br><span class="line">      encoded_frame_samples_.pop_front();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaOptimization::UpdateSentFramerate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (encoded_frame_samples_.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    avg_sent_framerate_ = encoded_frame_samples_.size();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> denom = encoded_frame_samples_.back().timestamp -</span><br><span class="line">              encoded_frame_samples_.front().timestamp;</span><br><span class="line">  <span class="keyword">if</span> (denom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    avg_sent_framerate_ =</span><br><span class="line">        (<span class="number">90000</span> * (encoded_frame_samples_.size() - <span class="number">1</span>) + denom / <span class="number">2</span>) / denom;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avg_sent_framerate_ = encoded_frame_samples_.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收端帧率"><a href="#接收端帧率" class="headerlink" title="接收端帧率"></a>接收端帧率</h3><p>在WebRTC中，将接收端帧率分为了三种：网络接收帧率——接收端输入帧率、解码器输出帧率、视频渲染帧率。</p><p><strong>1、网络接收帧率</strong></p><p>网络接收帧率统计的是接收端接收到网络发送过来的视频帧帧率。在完整接收到一帧数据后，由<strong>FrameBuffer</strong>类调用<em>ReceiveStatisticsProxy::OnCompleteFrame()</em>来统计。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCompleteFrame</span><span class="params">(<span class="keyword">bool</span> is_keyframe,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">size_t</span> size_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> now_ms = clock_-&gt;TimeInMilliseconds();</span><br><span class="line">  frame_window_.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(now_ms, size_bytes));</span><br><span class="line">  <span class="keyword">int64_t</span> old_frames_ms = now_ms - kRateStatisticsWindowSizeMs;</span><br><span class="line">  <span class="keyword">while</span> (!frame_window_.empty() &amp;&amp;</span><br><span class="line">         frame_window_.begin()-&gt;first &lt; old_frames_ms) &#123;</span><br><span class="line">    frame_window_accumulated_bytes_ -= frame_window_.begin()-&gt;second;</span><br><span class="line">    frame_window_.erase(frame_window_.begin());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> framerate =</span><br><span class="line">      (frame_window_.size() * <span class="number">1000</span> + <span class="number">500</span>) / kRateStatisticsWindowSizeMs;</span><br><span class="line">  stats_.network_frame_rate = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(framerate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、解码器输出帧率</strong></p><p>WebRTC实现了<strong>RateStatistics</strong>来统计解码器输出帧率，在编码结束后由<strong>VideoReceiveStream</strong>调用<em>ReceiveStatisticsProxy::OnDecodedFrame()</em>来统计。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDecodedFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> now = clock_-&gt;TimeInMilliseconds();</span><br><span class="line">  <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;crit_)</span></span>;</span><br><span class="line">  ++stats_.frames_decoded;</span><br><span class="line">  decode_fps_estimator_.Update(<span class="number">1</span>, now);</span><br><span class="line">  stats_.decode_frame_rate = decode_fps_estimator_.Rate(now).value_or(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、视频渲染帧率</strong></p><p>WebRTC实现了<strong>RateStatistics</strong>来统计视频渲染帧率，在视频渲染结束后由<strong>VideoReceiveStream</strong>调用<em>ReceiveStatisticsProxy::OnRenderedFrame()</em>来统计。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderedFrame</span><span class="params">(<span class="keyword">const</span> VideoFrame&amp; frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> now = clock_-&gt;TimeInMilliseconds();</span><br><span class="line">  <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;crit_)</span></span>;</span><br><span class="line">  renders_fps_estimator_.Update(<span class="number">1</span>, now);</span><br><span class="line">  stats_.render_frame_rate = renders_fps_estimator_.Rate(now).value_or(<span class="number">0</span>);</span><br><span class="line">  ++stats_.frames_rendered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送端帧率策略"><a href="#发送端帧率策略" class="headerlink" title="发送端帧率策略"></a>发送端帧率策略</h2><p>影响发送端帧率的主要因素包含：视频采集（摄像头/桌面）帧率、编码器性能。</p><h3 id="视频采集帧率策略"><a href="#视频采集帧率策略" class="headerlink" title="视频采集帧率策略"></a>视频采集帧率策略</h3><p>摄像头是视频采集的来源，其帧率决定了视频会议帧率的上限。与摄像头采集相关的参数包含：像素格式、帧率和分辨率。下表列出了ThinkPad T440P自带摄像头支持的部分视频格式：</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">分辨率</th><th style="text-align:center">帧率</th></tr></thead><tbody><tr><td style="text-align:center">MJPG</td><td style="text-align:center">1280x720</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">MJPG</td><td style="text-align:center">640x360</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">YUY2</td><td style="text-align:center">1280x720</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">YUY2</td><td style="text-align:center">640x360</td><td style="text-align:center">30</td></tr></tbody></table></div><p>可以看出对于YUY2格式，1280x720的帧率仅为10帧，要想达到30帧必须要采用MJPG格式。这是因为，同样是1280x720分辨率，30帧YUY2和MJPG格式需要传输的数据量分别为：</p><ul><li>YUY2：<em>1280x720x30x2x8=421Mbps</em></li><li>MJPG：<em>1280x720x30x3x8/20=32Mbps</em></li></ul><p>YUY2需要的传输带宽过大，所以很多摄像头对于RGB、YUV等格式1280x720仅支持10帧。然而10帧是远远不能够满足视频会议的帧率需求的，因此在选择视频采集规格时，需要注意像素格式、帧率和分辨率的权衡。在实际应用中，我们可以采集MJPG格式1280x720x30视频规格，然后在应用层转换为YUV格式。WebRTC在<em>“webrtc/modules/video_capture/video_capture_impl.cc”</em>的<strong>VideoCaptureImpl</strong>类中实现了转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frameInfo.codecType == kVideoCodecUnknown) &#123;</span><br><span class="line">  <span class="comment">/* Not encoded, convert to I420. */</span></span><br><span class="line">  <span class="keyword">const</span> VideoType commonVideoType =</span><br><span class="line">            RawVideoTypeToCommonVideoVideoType(frameInfo.rawType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (frameInfo.rawType != kVideoMJPEG &amp;&amp; CalcBufferSize(commonVideoType, width,</span><br><span class="line">                     <span class="built_in">abs</span>(height)) != videoFrameLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> stride_y = width, stride_uv = (width + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> target_width = width, target_height = height;</span><br><span class="line"></span><br><span class="line">  rtc::scoped_refptr&lt;I420Buffer&gt; buffer = I420Buffer::Create(</span><br><span class="line">      target_width, <span class="built_in">abs</span>(target_height), stride_y, stride_uv, stride_uv);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> conversionResult = ConvertToI420(</span><br><span class="line">      commonVideoType, videoFrame, <span class="number">0</span>, <span class="number">0</span>, width, height, videoFrameLength,</span><br><span class="line">      apply_rotation ? _rotateFrame : kVideoRotation_0, buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的YUV格式的视频数据会被送到编码器中被编码，需要注意：不是所有的视频数据都会被编码器编码，详细内容将在下一节介绍。</p><h3 id="采集编码丢帧策略"><a href="#采集编码丢帧策略" class="headerlink" title="采集编码丢帧策略"></a>采集编码丢帧策略</h3><p>受限于系统硬件性能和编码器性能，视频采集图片的速度有可能比编码器编码速度快，这将导致多余的图片帧在编码器任务队列中累积。由于视频会议需要较低的时延，编码器必须要及时处理最新的帧，此时WebRTC采取丢帧策略——<strong>当有多个帧在编码器任务队列时，只编码最新的一帧</strong>。WebRTC在<em>“webrtc/video/vie_encoder.cc”</em>文件<strong>EncodeTask</strong>类中实现了该策略：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  ++vie_encoder_-&gt;captured_frame_count_;</span><br><span class="line">  <span class="keyword">if</span> (--vie_encoder_-&gt;posted_frames_waiting_for_encode_ == <span class="number">0</span>) &#123;</span><br><span class="line">    vie_encoder_-&gt;EncodeVideoFrame(frame_, time_when_posted_us_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* There is a newer frame in flight. Do not encode this frame. */</span></span><br><span class="line">    LOG(LS_VERBOSE) &lt;&lt; <span class="string">&quot;Incoming frame dropped due to that the encoder is blocked.&quot;</span>;</span><br><span class="line">    ++vie_encoder_-&gt;dropped_frame_count_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，由于编码器是阻塞的，如果编码器性能或系统硬件性能较差，编码器会丢掉因阻塞而累积的帧，进而导致发送端帧率降低。在具体使用场景中，这往往会导致两种现象：</p><ul><li>接收端黑屏：如果发送端一开始就卡死在编码器中，接收端会一直黑屏，直到第一个帧编码完成；</li><li>接收端卡顿：如果发送端运行后经常阻塞在编码器中，接收端会卡顿，严重影响视频质量。</li></ul><p>因此，摄像头采集帧率并不等于编码器的实际输入帧率，<strong>MediaOptimization</strong>类中得到的编码器实际输入帧率，需要在下次编码前设置为编码器的输入帧率。</p><h3 id="恒定码率丢帧策略"><a href="#恒定码率丢帧策略" class="headerlink" title="恒定码率丢帧策略"></a>恒定码率丢帧策略</h3><p>除了上文所述的采集编码丢帧策略，WebRTC还实现了一种漏桶算法的变体，用于跟踪何时应该主动丢帧，以避免编码器无法保持其比特率时，产生过高的比特率。<a href="https://en.wikipedia.org/wiki/Leaky_bucket">漏桶算法</a>的示意图如下：</p><p><img src="../../assets/comm/webrtc-leaky-bucket-algorithm.jpg"></p><p><a href="https://en.wikipedia.org/wiki/Leaky_bucket">漏桶算法</a>的实现位于<em>“webrtc/modules/video_coding/frame_dropper.cc”</em>中的<strong>FrameDropper</strong>类，其实现了三个关键方法：</p><ul><li><em>Fill()</em></li><li><em>Leak()</em></li><li><em>DropFrame()</em></li></ul><p>从字面上可以看出，这三个方法对应于上图所示漏桶算法的三个操作。这三个方法都在<strong>MediaOptimization</strong>类被调用。</p><p>首先，来看看<strong>FrameDropper</strong>类的核心参数：</p><ul><li>漏桶容积：<em>accumulator<em>max</em></em>，其值为<em>target-bps×kLeakyBucketSizeSeconds</em>，随目标码率改变而改变；</li><li>漏桶累积：<em>accumulator_</em>，其表示漏桶累积的字节数，每次<em>Fill()</em>时增加，每次<em>Leak()</em>时减少，其最大值为<em>target-bps×kAccumulatorCapBufferSizeSecs</em>；</li><li>丢帧率：<em>drop<em>ratio</em></em>，其为一个指数滤波器，使丢帧率保持一个平滑的变化过程，每次<em>Leak()</em>后更新丢帧率；</li><li>关键帧率：<em>key<em>frame_ratio</em></em>，其为一个指数滤波器，使关键帧率保持一个平滑的变化过程，每次<em>Fill()</em>后更新；</li><li>差分帧码率：<em>delta<em>frame_size_avg_kbits</em></em>，其为一个指数滤波器，使关键帧率保持一个平滑的变化过程，每次<em>Fill()</em>后更新。</li></ul><p>其次，为了防止关键帧和较大的差分帧立即溢出，进而导致后续较小的帧出现较高丢帧，关键帧和较大的差分帧是不会被立即在桶中累计。相反，这些较大的帧会在漏桶中累计前，会分成若干小块，进而在<em>Leak()</em>操作中逐次累计这些小块，来防止较关键帧和较大的差分帧立即溢出。<strong>FrameDropper</strong>类增加了额外的几个参数来实现该策略：</p><ul><li><em>large<em>frame_accumulation_spread</em></em>：大帧最大拆分块数，四舍五入取整；</li><li><em>large<em>frame_accumulation_count</em></em>：大帧剩余拆分块数，四舍五入取整；</li><li><em>large<em>frame_accumulation_chunk_size</em></em>：单个块尺寸，其值为<em>framesize/large<em>frame_accumulation_count</em></em>。</li></ul><p>最后，来看看<strong>FrameDropper</strong>类的核心操作：</p><p><strong>1、<em>Fill()</em></strong></p><p>当视频帧被编码后，<strong>MediaOptimization</strong>类会调用<em>Fill()</em>方法来填充漏桶。调用顺序很简单，主要关注<em>Fill()</em>方法的实现——将大帧拆分为<em>large<em>frame_accumulation_count</em></em>个小块，并不累加<em>accumulator_</em>；将小帧直接累计<em>accumulator_</em>。<em>Fill()</em>方法同时需要更新<em>key<em>frame_ratio</em></em>和<em>delta<em>frame_size_avg_kbits</em></em>，用以计算大帧拆分块数和大帧判断。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fill</span><span class="params">(<span class="keyword">size_t</span> framesize_bytes, <span class="keyword">bool</span> delta_frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> framesize_kbits = <span class="number">8.0f</span> * <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(framesize_bytes) / <span class="number">1000.0f</span>;</span><br><span class="line">  <span class="keyword">if</span> (!delta_frame) &#123;</span><br><span class="line">    <span class="keyword">if</span> (large_frame_accumulation_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key_frame_ratio_.filtered() &gt; <span class="number">1e-5</span> &amp;&amp;</span><br><span class="line">          <span class="number">1</span> / key_frame_ratio_.filtered() &lt; large_frame_accumulation_spread_) &#123;</span><br><span class="line">        large_frame_accumulation_count_ =</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(<span class="number">1</span> / key_frame_ratio_.filtered() + <span class="number">0.5</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        large_frame_accumulation_count_ =</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(large_frame_accumulation_spread_ + <span class="number">0.5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      large_frame_accumulation_chunk_size_ =</span><br><span class="line">          framesize_kbits / large_frame_accumulation_count_;</span><br><span class="line">      framesize_kbits = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delta_frame_size_avg_kbits_.filtered() != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        (framesize_kbits &gt;</span><br><span class="line">         kLargeDeltaFactor * delta_frame_size_avg_kbits_.filtered()) &amp;&amp;</span><br><span class="line">        large_frame_accumulation_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">      large_frame_accumulation_count_ =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(large_frame_accumulation_spread_ + <span class="number">0.5</span>);</span><br><span class="line">      large_frame_accumulation_chunk_size_ =</span><br><span class="line">          framesize_kbits / large_frame_accumulation_count_;</span><br><span class="line">      framesize_kbits = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      delta_frame_size_avg_kbits_.Apply(<span class="number">1</span>, framesize_kbits);</span><br><span class="line">    &#125;</span><br><span class="line">    key_frame_ratio_.Apply(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  accumulator_ += framesize_kbits;</span><br><span class="line">  CapAccumulator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、<em>Leak()</em></strong></p><p><em>Leak()</em>操作按照编码器输入帧率的频率来执行，每次<strong>Leak</strong>的大小为<em>target_bps/input_fps</em>，每次<strong>Leak</strong>时需要判断是否需要累计<em>Fill()</em>方法拆分的块，进而更新<em>drop<em>ratio</em></em>。<em>drop<em>ratio</em></em>的更新遵循下列原则：</p><ul><li>当<em>accumulator_ &gt; 1.3f </em> accumulator<em>max</em><em>，</em>drop<em>ratio</em><em>基数调整为</em>0.8f*，提高丢帧率调整加速度；</li><li>当<em>accumulator_ &lt; 1.3f </em> accumulator<em>max</em><em>，</em>drop<em>ratio</em><em>基数调整为</em>0.9f*，降低丢帧率调整加速度。</li></ul><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Leak</span><span class="params">(<span class="keyword">uint32_t</span> input_framerate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> expected_bits_per_frame = target_bitrate_ / input_framerate;</span><br><span class="line">  <span class="keyword">if</span> (large_frame_accumulation_count_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    expected_bits_per_frame -= large_frame_accumulation_chunk_size_;</span><br><span class="line">    --large_frame_accumulation_count_;</span><br><span class="line">  &#125;</span><br><span class="line">  accumulator_ -= expected_bits_per_frame;</span><br><span class="line">  <span class="keyword">if</span> (accumulator_ &lt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">    accumulator_ = <span class="number">0.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (accumulator_ &gt; <span class="number">1.3f</span> * accumulator_max_) &#123;</span><br><span class="line">    <span class="comment">/* Too far above accumulator max, react faster */</span></span><br><span class="line">    drop_ratio_.UpdateBase(<span class="number">0.8f</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Go back to normal reaction */</span></span><br><span class="line">    drop_ratio_.UpdateBase(<span class="number">0.9f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (accumulator_ &gt; accumulator_max_) &#123;</span><br><span class="line">    <span class="comment">/* We are above accumulator max, and should ideally</span></span><br><span class="line"><span class="comment">     * drop a frame. Increase the dropRatio and drop</span></span><br><span class="line"><span class="comment">     * the frame later.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (was_below_max_) &#123;</span><br><span class="line">      drop_next_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drop_ratio_.Apply(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    drop_ratio_.UpdateBase(<span class="number">0.9f</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    drop_ratio_.Apply(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  was_below_max_ = accumulator_ &lt; accumulator_max_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、<em>DropFrame()</em></strong></p><p><em>DropFrame()</em>操作用来判断是否需要将输入到编码器的这一帧丢弃，其利用<em>drop<em>ratio</em></em>来使丢帧率保持一个平滑的变化过程。当<em>drop<em>ratio</em>.filtered() &gt;= 0.5f</em>时，表明连续丢弃多个帧（至少一个帧）；当<em>0.0f &lt; drop<em>ratio</em>.filtered() &lt; 0.5f</em>时，表明多个帧才会丢弃一个帧。具体的丢帧策略见实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FrameDropper::DropFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (drop_ratio_.filtered() &gt;= <span class="number">0.5f</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> denom = <span class="number">1.0f</span> - drop_ratio_.filtered();</span><br><span class="line">    <span class="keyword">if</span> (denom &lt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">      denom = <span class="number">1e-5</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int32_t</span> limit = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(<span class="number">1.0f</span> / denom - <span class="number">1.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">    <span class="keyword">int</span> max_limit = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(incoming_frame_rate_ * max_drop_duration_secs_);</span><br><span class="line">    <span class="keyword">if</span> (limit &gt; max_limit) &#123;</span><br><span class="line">      limit = max_limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drop_count_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      drop_count_ = -drop_count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drop_count_ &lt; limit) &#123;</span><br><span class="line">      drop_count_++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      drop_count_ = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drop_ratio_.filtered() &gt; <span class="number">0.0f</span> &amp;&amp; drop_ratio_.filtered() &lt; <span class="number">0.5f</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> denom = drop_ratio_.filtered();</span><br><span class="line">    <span class="keyword">if</span> (denom &lt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">      denom = <span class="number">1e-5</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int32_t</span> limit = -<span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(<span class="number">1.0f</span> / denom - <span class="number">1.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">    <span class="keyword">if</span> (drop_count_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      drop_count_ = -drop_count_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drop_count_ &gt; limit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (drop_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">        drop_count_--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drop_count_--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      drop_count_ = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  drop_count_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接收端帧率策略"><a href="#接收端帧率策略" class="headerlink" title="接收端帧率策略"></a>接收端帧率策略</h2><p>影响接收端帧率的主要因素包含：网络状况、解码器性能、渲染速度。</p><h3 id="网络状况导致丢帧"><a href="#网络状况导致丢帧" class="headerlink" title="网络状况导致丢帧"></a>网络状况导致丢帧</h3><p>网络因素对实时视频流的影响十分严重，当网络出现拥塞，导致较高的丢包率，明显的现象就是视频接收端帧率降到很低。比较严重时，接收端接收帧率可能只有几帧，导致无法进行正常的视频通话。WebRTC在<em>“webrtc/modules/video_coding/packet_buffer.cc”</em>的<strong>PacketBuffer</strong>中，将接收到的RTP包组合成一个完整的视频帧。之后，该完整的帧会被送到<em>“webrtc/modules/video_coding/rtp_frame_reference_finder.cc”</em>的<strong>RtpFrameReferenceFinder</strong>中。一个完整的帧可能是关键帧，也可能是参考帧，<strong>RtpFrameReferenceFinder</strong>类中关键帧直接送到解码器中处理。而对于参考帧，会判断其是否连续，若不连续会一直暂存在队列中，直到连续——送到解码器，或者下一个关键帧来了——从队列中删除。两个类相应的操作见下面两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PacketBuffer::InsertPacket</span><span class="params">(VCMPacket* packet)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RtpFrameReferenceFinder::ManageFrameGeneric</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RtpFrameObject&gt; frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> picture_id)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频会议软件通常会采用NACK和FEC等手段来降低丢包对视频通话质量的影响。同时，解码器一定时间内，没有收到可解码数据，会向发送端请求I帧，这也就在一定程度上保证帧率不会过于低。这部分代码实现与<em>“webrtc/video/video_receive_stream.cc”</em>的<strong>VideoReceiveStream</strong>类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoReceiveStream::Decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxWaitForFrameMs = <span class="number">3000</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;video_coding::FrameObject&gt; frame;</span><br><span class="line">  video_coding::FrameBuffer::ReturnReason res =</span><br><span class="line">      frame_buffer_-&gt;NextFrame(kMaxWaitForFrameMs, &amp;frame);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == video_coding::FrameBuffer::ReturnReason::kStopped)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (frame) &#123;</span><br><span class="line">    <span class="keyword">if</span> (video_receiver_.Decode(frame.get()) == VCM_OK)</span><br><span class="line">      rtp_stream_receiver_.FrameDecoded(frame-&gt;picture_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RequestKeyFrame();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码导致丢帧"><a href="#解码导致丢帧" class="headerlink" title="解码导致丢帧"></a>解码导致丢帧</h3><p>看一下WebRTC内调用解码模块的代码，就可以看出WebRTC解码导致失败的可能原因。这部分代码位于<em>“webrtc/modules/video_coding/video_receiver.cc”</em>，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">Decode</span><span class="params">(<span class="keyword">const</span> VCMEncodedFrame&amp; frame)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Decode a frame */</span></span><br><span class="line">  <span class="keyword">int32_t</span> ret = _decoder-&gt;Decode(frame, clock_-&gt;TimeInMilliseconds());</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for failed decoding, run frame type request callback if needed. */</span></span><br><span class="line">  <span class="keyword">bool</span> request_key_frame = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret == VCM_ERROR_REQUEST_SLI) &#123;</span><br><span class="line">      <span class="keyword">return</span> RequestSliceLossIndication(</span><br><span class="line">          _decodedFrameCallback.LastReceivedPictureID() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      request_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == VCM_REQUEST_SLI) &#123;</span><br><span class="line">    ret = RequestSliceLossIndication(</span><br><span class="line">        _decodedFrameCallback.LastReceivedPictureID() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!frame.Complete() || frame.MissingFrame()) &#123;</span><br><span class="line">    request_key_frame = <span class="literal">true</span>;</span><br><span class="line">    ret = VCM_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (request_key_frame) &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">cs</span><span class="params">(&amp;process_crit_)</span></span>;</span><br><span class="line">    _scheduleKeyRequest = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，如果解码器无法将接收到的数据解码，要么发送SLI要么发送PLI，请求重新发送关键帧。从SLI/PLI发出到收到可解码的关键帧这个时间间隔内，接收端的帧率会比正常情况低。</p><h3 id="渲染导致丢帧"><a href="#渲染导致丢帧" class="headerlink" title="渲染导致丢帧"></a>渲染导致丢帧</h3><p>在实际应用中，经过WebRTC处理后显示的帧率较大，但最终的显示效果却比较差，能够感觉到明显的卡顿。这就和应用软件的渲染有关。研究不深，暂不撰写。</p>]]></content>
    
    
    <summary type="html">从WebRTC帧率调整策略窥探实时视频应用需要考虑的帧率问题。</summary>
    
    
    <content src="http://wx2.sinaimg.cn/large/61b57e82gy1fj91q7dx70j22r70xl76p.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="WebRTC" scheme="https://www.freehacker.cn/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>H.264/MPEG-4 AVC学习</title>
    <link href="https://www.freehacker.cn/comm/codec-h264/"/>
    <id>https://www.freehacker.cn/comm/codec-h264/</id>
    <published>2017-10-28T11:00:34.000Z</published>
    <updated>2021-02-24T11:54:25.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>任何一个傻瓜都会写能够让机器理解的代码，只有好的程序员才能写出人类可以理解的代码。</p></blockquote><p>H.264，又称为 MPEG-4 第10部分，高级视频编码（英语：MPEG-4 Part 10, Advanced Video Coding，缩写为 MPEG-4 AVC）是一种面向块的基于运动补偿的视频编码标准 。<a id="more"></a></p><p>对于视频序列样本来说，使用 H.264 编码器能够比使用有运动补偿的 MPEG-4 编码器降低50%的比特率(bps)。在没有运动补偿的情况下，H.264 编码器的效率至少比 MPEG-4 编码器高3倍，比 M-JPEG 编码器高6倍。除了能够显著的提高编码效率外，H.264的优点还包括：提供高质量的图像、容错能力强、网络适应性强、低时延等。</p><p>有关 H264 详细的介绍可以参考</p><ul><li><strong>维基百科：H.264/MPEG-4 AVC</strong>，<a href="https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC">中文地址</a>/<a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">英文地址</a></li><li><strong>H264相关标准</strong>，中英对照版本见<a href="https://wenku.baidu.com/view/b650103310661ed9ad51f381.html">文献</a>。</li></ul><h2 id="H-264原理"><a href="#H-264原理" class="headerlink" title="H.264原理"></a>H.264原理</h2><p>视频编码的核心思想是是去除冗余信息，冗余信息包括以下几个方面：</p><ul><li>空间冗余：图像相邻像素之间有较强的相关性</li><li>时间冗余：视频序列的相邻图像之间内容相似</li><li>编码冗余：不同像素值出现的概率不同</li><li>视觉冗余：人的视觉系统对某些细节不敏感</li><li>知识冗余：规律性的结构可由先验知识和背景知识得到</li></ul><p>视频编解码器（编码器/解码器）是指两个协同运行的压缩-解压算法。使用不同标准的视频编解码器通常彼此之间互不兼容。</p><p>H.264压缩方法如下：</p><ul><li>分组：把几帧图像分为一组(<strong>GOP</strong>，也就是一个序列)，为防止运动变化，帧数不宜取多；</li><li>定义帧：将每组内各帧图像定义为三种类型，即I帧、B帧和P帧；</li><li>预测帧：以I帧做为基础帧，以I帧预测P帧，再由I帧和P帧预测B帧;</li><li>数据传输：最后将I帧数据与预测的差值信息进行存储和传输。</li></ul><p>H.264编解码流程如下：</p><ul><li>H.264编码流程</li></ul><p><img src="../../assets/comm/h264-encoder-block-diagram.png"></p><ul><li>H.264解码流程</li></ul><p><img src="../../assets/comm/h264-decoder-block-diagram.png"></p><h2 id="H-264帧场"><a href="#H-264帧场" class="headerlink" title="H.264帧场"></a>H.264帧场</h2><h3 id="帧与场"><a href="#帧与场" class="headerlink" title="帧与场"></a>帧与场</h3><p>要想了解帧与场的概念，需先掌握<strong>逐行扫描</strong>和<strong>隔行扫描</strong>的区别。在英语中，逐行扫描为<em>Progressive Scanning</em>，隔行扫描为<em>Interlace Scanning</em>。</p><p>逐行比较好理解，假设一帧图像的大小是704x576，那么逐行的话就是576行。隔行图像，是早期电视信号中引入的概念，把一帧图像分为上下两场，两场图像在时间上具有先后，但传输时同时传送到显示端，显示端在显示按各自的时间分开进行显示。该方式主要是利用了人眼的余辉效应，通过隔行显示，提高了显示的流畅性。</p><p><img src="../../assets/comm/auvi-interlace-scanning.png" alt="隔行扫描"></p><p><strong>场</strong>（Field）和<strong>帧</strong>（Frame）的概念一目了然：</p><ul><li>隔行扫描得到场，场分为底场和顶场，底场包含偶数行数据，顶场包含奇数行数据；</li><li>逐行扫描得到帧，帧包含一张图片完整的信息，底场和顶场一起包含完整的一帧信息。</li></ul><p>对于一个具体的序列参数集来说，编码场的宽度和编码帧的宽度是相同的，而编码场的高度是是编码帧的高度的一半。</p><h3 id="帧组成"><a href="#帧组成" class="headerlink" title="帧组成"></a>帧组成</h3><p>H.264多了个图像组成一个<strong>视频系列</strong>（GOP），每个图像由一<strong>帧</strong>（Frame）组成。帧又可以分成一个或几个<strong>片</strong>（Slice）。片由<strong>宏块</strong>（Macro Block）组成，一帧中每个片的宏块数不一定相同。每个宏块由一个16×16的亮度数组和两个8×8的色差数组组成。一个720×480分辨率的图像可以被划分为1350（45×30）个宏块。</p><p><img src="../../assets/comm/h264-slice.png" alt="SLICE"></p><p>宏块是编码处理的基本单元。一个帧是可以分割成多个片来编码的，构成I_Slice、P_Slice、B_Slice、SP_Slice和SI_Slice，而一个片编码之后被打包进一个NAL单元。编码片相互间独立，这样做的目的是为了限制误码的扩散和传输。</p><p>I_Slice、P_Slice和B_Slice对应于I帧、P帧和B帧，三者之区别如下：</p><ul><li>I_slice ：只使用当前片中已解码的像素进行帧内预测。</li><li>P_slice：可能使用当前片中的像素进行帧内预测，也可能使用前面参考帧进行帧间预测。</li><li>B_slice：可能使用当前片中的象素进行帧内预测，也可能使用前后参考帧进行帧间预测。</li></ul><h3 id="帧分类"><a href="#帧分类" class="headerlink" title="帧分类"></a>帧分类</h3><p>根据H.264的不同类别，编码器会使用不同类型的帧，例如I帧、P帧和B帧。</p><ul><li><p><strong>I帧</strong>（帧内编码帧）是一种自带全部信息的独立帧，无需参考其它图像便可独立进行解码。</p><p>视频序列中的第一个帧始终都是I帧。如果所传输的比特流遭到破坏，则需要将I帧用作新查看器的起始点或重新同步点。I帧可以用来实现快进、快退以及其它随机访问功能。如果新的客户端将参与查看视频流，编码器将以相同的时间间隔或者根据要求自动插入I帧。I帧的缺点在于它们会占用更多的数据位，但从另一方面看，I帧不会产生可觉察的模糊现象。</p></li><li><p><strong>P帧</strong>（帧间预测编码帧）需要参考前面的I帧和/或P帧的不同部分才能进行编码。</p><p>与I帧相比，P帧通常占用更少的数据位，但其缺点是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感。</p></li><li><p><strong>B帧</strong>（双向预测编码帧）需要同时以前面的帧和后面的帧作为参考帧。</p></li></ul><p>下图为带有I帧、B帧和P帧的典型视频序列。P帧只需要参考前面的I帧或P帧，而B帧则需要同时参考前面和后面的I帧或P 帧。</p><p><img src="../../assets/comm/h264-i-p-b.png" alt="带有I帧、B帧和P帧的典型视频序列"></p><p>当视频解码器逐个帧地对比特流进行解码以便重构视频时，必须始终从I帧开始解码。如果使用了P帧和B帧，则必须与参考帧一起解码。在H.264基准类中，仅使用I帧和P帧。由于基准类没有使用B帧，所以可以实现低延时，因此是网络摄像机和视频编码器的理想选择。</p><h2 id="H-264实现"><a href="#H-264实现" class="headerlink" title="H.264实现"></a>H.264实现</h2><p><img src="../../assets/comm/h264-overall.png" alt="H.264实现流程"></p><h3 id="帧内预测"><a href="#帧内预测" class="headerlink" title="帧内预测"></a>帧内预测</h3><p>在H.264中，将通过新的高级帧内预测方法对I帧进行编码。这种方法通过对帧中每个宏块内较小的像素块进行连续预测，通过一组不同方向上的相邻块来预测当前块，可以大大减少I帧所占的数据位并保持较高的质量。这一点可通过在与进行帧内编码的新4×4像素块相邻接的前几个编码像素中，寻找匹配的像素来实现。通过重复利用已编码的像素值，可以极大地减少需要编码的位数。</p><p>帧内预测编码的是预测块和实际块差值，这种方法能够有效减少平滑背景小的空间冗余。</p><p><img src="../../assets/comm/h264-intra-estimation.png" alt="差分编码"></p><h3 id="帧间预测"><a href="#帧间预测" class="headerlink" title="帧间预测"></a>帧间预测</h3><p>H.264 通过差分编码来减少视频数据量，大多数视频压缩标准都采用这种方法：在差分编码中，会将一个帧与参考帧（即前面的 I 帧或 P 帧）进行对比，然后只对那些相对于参考帧来说发生了变化的像素进行编码。通过这种方法，可以降低需要进行编码和发送的像素值。</p><p>对差分编码（包括H.264在内的大多数视频压缩标准都采用这种方法）来说，只有第一个图像（I帧）是将全帧图像信息进行编码。在后面的两个图像（P帧）中，其静态部分（即房子）将参考第一个图像，而仅对运动部分（即正在跑步的人）使用运动矢量进行编码，从而减少发送和存储的信息量。</p><p><img src="../../assets/comm/h264-diff-encode.png" alt="差分编码"></p><p>然而，如果视频中存在大量物体运动的话，差分编码将无法显著减少数据量。这时，可以采用基于块的<strong>运动补偿</strong>技术。基于块的运动补偿考虑到视频序列中构成新帧的大量信息都可以在前面的帧中找到，但可能会在不同的位置上。所以，这种技术将一个帧分为一系列的宏块。然后，通过在参考帧中查找匹配块的方式，逐块地构建或者”预测”一个新帧（例如P帧）。如果发现匹配的块，编码器只需要对参考帧中发现匹配块的位置进行编码。与对块的实际内容进行编码相比，只对运动矢量进行编码可以减少所占用的数据位。</p><p><img src="../../assets/comm/h264-motion-compesation.png" alt="运动补偿"></p><p>为了提高编码效率，宏块被分割成更小的子块，下图给出了 H.264、MPEG-4和MPEG-2运动补偿技术特性对比：</p><p><img src="../../assets/comm/h264-motion-estimation.png" alt="运动补偿"></p><p>同时，由于运动是个持续的过程，拍摄运动图像时可能会出现偏移和遮挡，拍摄角度会不停的来回切换，H.264引入了多参考帧的概念。</p><p><img src="../../assets/comm/h264-multi-reference-frame.png" alt="多参考帧"></p><h3 id="整数变换"><a href="#整数变换" class="headerlink" title="整数变换"></a>整数变换</h3><p>从帧间预测和帧内预测得到的结果需要从空域转换成频域，H.264/MPEG-4 AVC采用<strong>4×4 DCT-like</strong>整数变换。相对于MPEG-2和MPEG-4基于浮点系数的<strong>8×8 DCT</strong>变换，整数系数能够消除浮点系数固有的舍入误差，进而消除浮点系数引起的<code>drifting artifacts</code>。同时，H.264/MPEG-4 AVC较小的块大小也减少了阻塞和<code>ringing artifacts</code>。</p><p><img src="../../assets/comm/h264-transform.png" alt="整数变换"></p><p>H.264协议中的变化方式主要有三种：4×4残差变化（整数DCT变换）、16×16帧内模式下4×4亮度直流系数变化（离散哈达玛变化）、2×2色度直流系数变化（离散哈达玛变化）。</p><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>从<strong>整数变化</strong>阶段得到的系数需要被<a href="https://www.vcodex.com/h264avc-4x4-transform-and-quantization/"><strong>量化</strong></a>，用以减少整数系数的整体精度，并趋向于消除高频系数，保持感知质量。量化的原则是在不降低视觉效果的前提下尽量减少图像编码长度，减少视觉恢复中不必要的信息。</p><p><img src="../../assets/comm/h264-quantization.png" alt="量化"></p><p>一般的标量量化器原理如下：</p><script type="math/tex; mode=display">{Z}_{ij} = round({Y}_{ij}/{Q}_{step})</script><p>其中，<script type="math/tex">{Y}_{ij}</script>表示一个宏块经过整数DCT转换后的系数，<script type="math/tex">{Z}_{ij}</script>是输出的量化系数，<script type="math/tex">{Q}_{step}</script>是量化步长。<strong>量化步长</strong>决定了量化器的编码压缩率以及图像精度。如果量化步长较大，则量化值<script type="math/tex">{Z}_{ij}</script>动态范围较小，其相应的编码长度较小，但反量化会损失较多的图像细节信息；如果量化步长较小，则量化值<script type="math/tex">{Z}_{ij}</script>动态范围较大，其相应的编码长度较大，但图像损失较少。H.264编码器根据图像值实际动态范围自动改变量化步长值，在编码长度和图像精度之间折衷，达到整体最佳效果。</p><p>在H.264中，使用量化参数QP（Quantization Parameter）来标识量化步长的序号，亮度编码的量化步长<script type="math/tex">{Q}_{step}</script>共有52个值，QP为0-51；色度编码的量化步长<script type="math/tex">{Q}_{step}</script>共有39个值，QP为0-39。QP取最小值0 时，表示量化最精细；相反，QP取最大值51/39时，表示量化是最粗糙的。亮度编码的QP每增加6，量化步长<script type="math/tex">{Q}_{step}</script>增加一倍。亮度编码的量化步长信息如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">QP</th><th style="text-align:center"><script type="math/tex">{Q}_{step}</script></th><th style="text-align:center">QP</th><th style="text-align:center"><script type="math/tex">{Q}_{step}</script></th><th style="text-align:center">QP</th><th style="text-align:center"><script type="math/tex">{Q}_{step}</script></th><th style="text-align:center">QP</th><th style="text-align:center"><script type="math/tex">{Q}_{step}</script></th><th style="text-align:center">QP</th><th style="text-align:center"><script type="math/tex">{Q}_{step}</script></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0.625</td><td style="text-align:center">13</td><td style="text-align:center">2.25</td><td style="text-align:center">22</td><td style="text-align:center">8</td><td style="text-align:center">33</td><td style="text-align:center">28</td><td style="text-align:center">44</td><td style="text-align:center">104</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0.6875</td><td style="text-align:center">12</td><td style="text-align:center">2.5</td><td style="text-align:center">23</td><td style="text-align:center">9</td><td style="text-align:center">34</td><td style="text-align:center">32</td><td style="text-align:center">45</td><td style="text-align:center">112</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0.8125</td><td style="text-align:center">13</td><td style="text-align:center">2.75</td><td style="text-align:center">24</td><td style="text-align:center">10</td><td style="text-align:center">35</td><td style="text-align:center">36</td><td style="text-align:center">46</td><td style="text-align:center">128</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0.875</td><td style="text-align:center">14</td><td style="text-align:center">3.25</td><td style="text-align:center">25</td><td style="text-align:center">11</td><td style="text-align:center">36</td><td style="text-align:center">40</td><td style="text-align:center">47</td><td style="text-align:center">144</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">15</td><td style="text-align:center">3.5</td><td style="text-align:center">26</td><td style="text-align:center">13</td><td style="text-align:center">37</td><td style="text-align:center">44</td><td style="text-align:center">48</td><td style="text-align:center">160</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">1.125</td><td style="text-align:center">16</td><td style="text-align:center">4</td><td style="text-align:center">27</td><td style="text-align:center">14</td><td style="text-align:center">38</td><td style="text-align:center">52</td><td style="text-align:center">49</td><td style="text-align:center">176</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1.25</td><td style="text-align:center">17</td><td style="text-align:center">4.5</td><td style="text-align:center">28</td><td style="text-align:center">16</td><td style="text-align:center">39</td><td style="text-align:center">56</td><td style="text-align:center">50</td><td style="text-align:center">208</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1.375</td><td style="text-align:center">18</td><td style="text-align:center">5</td><td style="text-align:center">29</td><td style="text-align:center">18</td><td style="text-align:center">40</td><td style="text-align:center">64</td><td style="text-align:center">51</td><td style="text-align:center">224</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1.625</td><td style="text-align:center">19</td><td style="text-align:center">5.5</td><td style="text-align:center">30</td><td style="text-align:center">20</td><td style="text-align:center">41</td><td style="text-align:center">72</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1.75</td><td style="text-align:center">20</td><td style="text-align:center">6.5</td><td style="text-align:center">31</td><td style="text-align:center">22</td><td style="text-align:center">42</td><td style="text-align:center">80</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">2</td><td style="text-align:center">21</td><td style="text-align:center">7</td><td style="text-align:center">32</td><td style="text-align:center">26</td><td style="text-align:center">43</td><td style="text-align:center">88</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="循环滤波"><a href="#循环滤波" class="headerlink" title="循环滤波"></a>循环滤波</h3><p>H.264 / MPEG-4 AVC定义了一种<strong>去块滤波器</strong>（de-blocking filter ），其对16×16宏块和4×4块边界进行操作。 在宏块的情况下，滤波器旨在去除可能由具有不同估计类型（例如，运动与帧内估计）的相邻宏块和/或不同的量化尺度产生的<strong>伪像</strong>。 在块的情况下，滤波器旨在去除可能由变换/量化引起的伪像和相邻块之间的<strong>运动矢量差异</strong>。 循环滤波器通常使用内容自适应非线性滤波器来修改宏块/块边界的任一侧上的两个像素。</p><h3 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h3><p>在进行熵编码之前，必须对4x4量化系数进行序列化。 根据这些系数是否是原始的运动估计或帧内估计，选择不同的扫描模式来创建串行化流。 扫描模式将系数从低频到高频排列。 然后，由于较高频率的量化系数趋向于零，所以使用游程长度编码来分组尾随零，导致更有效的熵编码。</p><p>熵编码将表示运动矢量、量化系数和宏块头的符号映射到实际位中，熵编码通过将较少数量的比特分配给频繁使用的符号和较大数量的比特到较不频繁使用的符号来提高编码效率。</p><p><img src="../../assets/comm/h264-entropy-coding.png" alt="熵编码"></p><p>下列表格描述了两种主要类型的熵编码：<strong>Variable Length Coding (VLC)</strong>和<strong>Context Adaptive Binary Arithmetic Coding (CABAC)</strong>。</p><p><img src="../../assets/comm/h264-entropy-coding-comparison.png" alt="熵编码比较"></p><h2 id="Level-和-Profile"><a href="#Level-和-Profile" class="headerlink" title="Level 和 Profile"></a>Level 和 Profile</h2><p>H.264 标准的一个重要方面是通过级别（Level）和档次（Profile）中提供的功能，以最佳的方式支持常见应用和通用格式。Profile 是对视频压缩特性的描述（CABAC 呀、颜色采样数等等），Level 是对视频本身特性的描述（码率、分辨率、帧率）。简单来说，Profile 越高，就说明采用了越高级的压缩特性。Level 越高，视频的码率、分辨率、帧率越高。</p><p>H.264 从低到高划分了很多 Profile 和 Level，在维基百科英文版中能够看到详细的表格，在本节末尾会贴出相关表格内容。</p><p>H.264 支持四个 Profile，分别为：</p><ul><li>BP（Baseline Profile）：提供I/P帧，仅支持Progressive和CAVLC，多应用于”视频会话”，如可视电话、会议电视、远程教学、视频监控等实时通信领域；</li><li>XP（Extended profile）提供I/P/B/SP/SI帧，仅支持Progressive和CAVLC，多应用于流媒体领域，如视频点播、基于网络的视频监控等；</li><li>MP（Main profile）提供I/P/B帧，支持Progressive和Interlaced，提供CAVLC和CABAC。多应用于数字电视广播、数字视频存储等领域；</li><li>HiP（High profile）在Main profile基础上新增8*8帧内预测，像素精度提高到10位或14位。多应用于对高分辨率和高清晰度有特别要求的领域。</li></ul><p><img src="../../assets/comm/h264-profile-classification.jpg" alt="H.264 Profile"></p><p>至于Level和Profile的相关表格如下：</p><ul><li>H.264 Profile</li></ul><p><img src="../../assets/comm/h264-profile.jpg" alt="H.264 Profile"></p><ul><li>H.264 Level</li></ul><p><img src="../../assets/comm/h264-level.jpg" alt="H.264 Level"></p><h2 id="H-264架构"><a href="#H-264架构" class="headerlink" title="H.264架构"></a>H.264架构</h2><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>制定H.264的主要目标有两个：</p><ul><li>得到高的视频压缩比；</li><li>具有良好的网络亲和性。</li></ul><p>为此，H.264的功能分为两层：视频编码层（VLC，Video Coding Layer）和网络抽象层（NAL，Network Abstraction Layer）。</p><p><img src="../../assets/comm/h264-layered-architecture.png"></p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>视频编码层进行视频数据压缩、解压缩操作，而网络抽象层专门为视频编码信息提供头文件信息，安排格式以方便网络传输和介质存储。VCL数据即编码处理的输出，它表示被压缩编码后的视频数据序列。在VCL数据传输或存储之前，这些编码的VCL数据，先被映射或封装进NAL单元中。每个NAL单元包含一个原始字节序列负载（RBSP，Raw Byte Sequence Payload）、一组对应于视频编码数据的NAL头信息。其具体结构如下图：</p><p><img src="../../assets/comm/h264-nal.jpg" alt=""></p><p>在H.264编码过程中，存在三种不同的数据形式：</p><ul><li>SODB， String of Data Bits，数据比特串，是最原始的编码数据，即VCL数据；VCL层是对核心算法引擎，块，宏块及片的语法级别的定义，他最终输出编码完的数据SODB</li></ul><ul><li>RBSP，Raw Byte Sequence Payload，原始字节序列载荷，在SODB的后面填加了结尾比特（RBSP trailing bits 一个bit”1”）若干比特”0”,以便字节对齐；</li><li>EBSP，Encapsulation Byte Sequence Packets，扩展字节序列载荷，在RBSP基础上填加了仿校验字节（0X03）。</li></ul><blockquote><p> 加上仿校验字节的原因是：EBSP被封装为NALU时，需要为其添加开始前缀，如果该NALU对应的Slice为一帧的开始，则用’0x000000001’，否则使用’0x000001’。为了使NALU主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉。也称为脱壳操作。</p></blockquote><h3 id="码流结构"><a href="#码流结构" class="headerlink" title="码流结构"></a>码流结构</h3><p>在H.264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流，以IDR帧开始，到下一个IDR帧结束，中间包含若干<strong>访问单元</strong>（Access Unit）。从宏观上来说，SPS、PPS、IDR 帧（包含一个或多个I-Slice）、P 帧（包含一个或多个P-Slice ）、B 帧（包含一个或多个B-Slice ）共同构成典型的H.264码流结构。</p><h3 id="SPS-PPS"><a href="#SPS-PPS" class="headerlink" title="SPS/PPS"></a>SPS/PPS</h3><p>SPS，Sequence Parameter Sets，序列参数集，是H.264码流序列的第一个NALU，PPS，Picture Parameter Set，图像参数集，是H.264码流序列的第二个NALU。</p><p>SPS和PPS中包含了初始化H.264解码器所需要的信息参数，包括编码所用的profile、level、图像的宽和高、deblock滤波器等。SPS语法单元存放一个视频序列共同特征，而PPS语法单元各个图像的典型特征。SPS和PPS都各自对应于一个NALU。</p><p>只有视频序列之间才能切换SPS，即只有IDR帧的第一个slice才可以切换SPS；只有图像之间才能切换PPS，即只有每帧图像的第一个slice才能切换PPS。</p><h3 id="IDR-P-B"><a href="#IDR-P-B" class="headerlink" title="IDR/P/B"></a>IDR/P/B</h3><p>IDR，Instantaneous Decoder Refresh，即时解码器刷新，是H.264码流序列的第三个NALU。</p><p>IDR帧都是I帧，但是I帧并不一定是IDR帧。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p><p>在IDR帧之后可能存在I帧、P帧和B帧，这个具体看使用的是哪种Profile。</p><h2 id="H-264语法结构"><a href="#H-264语法结构" class="headerlink" title="H.264语法结构"></a>H.264语法结构</h2><p>NALU，Network Abstract Layer Unit，是H.264的最高抽象层，H.264的所有语法结构最终都被封装成NALU，同时会加入一些网络相关信息。码流中的NALU单元必须定义合适的分隔符，否则无法区分。H.264 视频压缩标准的附录B采用前缀码<code>“00 00 01”/“00 00 00 01”</code>作为NALU的分隔符，可以通过搜索前缀码<code>“00 00 01”/“00 00 00 01”</code>来识别一个NALU。</p><p>H.264视频流是以NAL单元传送的，但在一个NAL单元里面，可能既存放I-Slice（P-Slice或B-Slice），也可能存放图像的其他信息，比如SPS、PPS。根据H.264语法结构，根据的NAL类型可以分为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NAL_SLICE     = 1   SLICE非IDR不分割</span><br><span class="line">NAL_SLICE_DPA = 2   SLICE数据分割块A</span><br><span class="line">NAL_SLICE_DPB = 3   SLICE数据分割快B</span><br><span class="line">NAL_SLICE_DPC = 4   SLICE数据分割块C</span><br><span class="line">NAL_SLICE_IDR = 5   SLICE关键帧</span><br><span class="line">NAL_SEI       = 6   补充增强信息单元帧</span><br><span class="line">NAL_SPS       = 7   序列参数集</span><br><span class="line">NAL_PPS       = 8   图像参数集</span><br><span class="line">NAL_AUD       = 9   分界符</span><br><span class="line">NAL_EOSEQ     = 10  序列结束</span><br><span class="line">NAL_EOSTREAM  = 11  码流结束</span><br><span class="line">NAL_FILLER    = 12  填充</span><br><span class="line">              = 13</span><br><span class="line">              = ...</span><br><span class="line">              = 23  13~23保留</span><br><span class="line">              = 24</span><br><span class="line">              = ...</span><br><span class="line">              = 31  24~32不保留，RTP打包时会用到</span><br></pre></td></tr></table></figure><p>将数据块分割为A、B、C，主要目的是为了对重要程度不同的数据进行不同程度的保护。其中24~32类型是不保留的，其在RTP打包时会用到：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型取值</th><th style="text-align:center">对应类型</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">24</td><td style="text-align:center">STAP-A</td><td style="text-align:center">Single-time aggregation packet</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">STAP-B</td><td style="text-align:center">Single-time aggregation packet</td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">MTAP16</td><td style="text-align:center">Multi-time aggregation packet</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">MTAP24</td><td style="text-align:center">Multi-time aggregation packet</td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">FU-A</td><td style="text-align:center">Fragmentation unit</td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">FU-B</td><td style="text-align:center">Fragmentation unit</td></tr><tr><td style="text-align:center">30-31</td><td style="text-align:center">undefined</td></tr></tbody></table></div><h3 id="FU-A"><a href="#FU-A" class="headerlink" title="FU_A"></a>FU_A</h3><p>对于比较大的NALU单元，是无法一次通过RTP发送的（RTP的MTU为1500），所以必须要拆包，将较大的NALU拆分为FU-A包。这里面有拆包和解包两个概念：</p><ul><li>拆包：当编码器在编码时需要将原有一个NAL按照FU-A进行分片，原有的NAL的单元头与分片后的FU-A的单元头有如下关系：</li></ul><blockquote><p>原始的NAL头的前三位为FU indicator的前三位，原始的NAL头的后五位为FU header的后五位，FU indicator与FU header的剩余位数根据实际情况决定。</p></blockquote><ul><li>解包：当接收端收到FU-A的分片数据，需要将所有的分片包组合还原成原始的NAl包时，FU-A的单元头与还原后的NAL的关系如下：</li></ul><blockquote><p>还原后的NAL头的八位是由FU indicator的前三位加FU header的后五位组成，即：nal_unit_type = (fu_indicator &amp; 0xe0) | (fu_header &amp; 0x1f)</p></blockquote><h2 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h2><p>H.264 的开源实现包括：OpenH264 和 x264。OpenH264 是思科实现的开源 H.264 编码，OpenH264 是思科实现的开源 H.264 编码。两者的对比如下：</p><ul><li>OpenH264 CPU 的占用相对 x264 低很多；</li><li>OpenH264 只支持 baseline profile，x264 支持更多 profile；</li><li>x264 需要专利费用，而 OpenH264 不需要专利费用；</li><li>x264 的主要功能在于进行 H.264 的视频编码，而不是作为解码器之用。</li></ul><h2 id="其他标准"><a href="#其他标准" class="headerlink" title="其他标准"></a>其他标准</h2><p>目前能与H.264相提并论的编码算法包括：</p><ul><li>HEVC/H.265：开源实现包括 libde265 和 x265，需专利费；</li><li>VP8：开源实现为 libvpx，无专利费；</li><li>VP9：开源实现为 ibvpx，无专利费。</li></ul><p>几种编码方案中，HEVC 对 VP9 和 H.264 在码率上有较大优势，在相同 PSNR 下分别节省了 48.3% 和 75.8%。H.264 在编码时间上有巨大优势，对比 VP9 和 HEVC(H.265) ，HEVC 是 VP9 的 6 倍，VP9 是 H.264 的将近 40 倍。</p><p>在H.264之前，还有一些前辈算法，包括：</p><ul><li>H.261、H.263</li><li>MPEG-1、MPEG-2、MPEG-4</li><li>JPEG、JPEG2000</li><li>AVS</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://web.cs.ucla.edu/classes/fall03/cs218/paper/H.264_MPEG4_Tutorial.pdf"> H.264/MPEG-4 AVC Video Compression Tutorial</a></li><li><a href="http://lib.mdp.ac.id/ebook/Karya%20Umum/Video-Compression-Video-Coding-for-Next-generation-Multimedia.pdf">Video Compression Video Coding for Next Generation Multimedia</a></li><li><a href="http://www.cc.ntut.edu.tw/~shyang/Journal%20Papers/H264_AVC.pdf">H.264/AVC 技術與應用簡介</a></li><li><a href="http://iphome.hhi.de/wiegand/assets/pdfs/h264-AVC-Standard.pdf">The H.264/MPEG4 Advanced Video Coding Standard and its Applications</a></li><li><a href="http://tcs.rwth-aachen.de/lehre/Komprimierung/SS2012/ausarbeitungen/H264-MPEG4.pdf">H.264/MPEG-4 Advanced Video Coding</a></li><li><a href="http://www.springer.com/cda/content/document/cda_downloaddocument/9781461422297-c1.pdf">Understanding the Application: An Overview of the H.264 Standard</a></li><li><a href="https://www.ittiam.com/wp-content/knowledge-center/publications/2005/H.264_Advanced_video_compression_standard.pdf">H.264 Advanced Video Compression Standard</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.142.1068&amp;rep=rep1&amp;type=pdf">Video coding with H.264/AVC: Tools, Performance, and Complexity</a></li><li><a href="https://engineering.purdue.edu/~ace/thesis/igarta/thesis-igarta.pdf">A STUDY OF MPEG-2 AND H.264 VIDEO CODING</a></li><li><a href="http://lib.mdp.ac.id/ebook/Karya%20Umum/Video-Compression-Video-Coding-for-Next-generation-Multimedia.pdf">H.264 and MPEG-4 Video Compression Video Coding for Next-generation Multimedia</a></li><li><a href="http://files.cnblogs.com/files/irish/The_H.264_advanced_video_compression_standard.pdf">The H.264 Advanced Video Compression Standard, Second Edition</a></li><li><a href="https://www.itu.int/rec/T-REC-H.264">H.264 : Advanced video coding for generic audiovisual services</a></li></ul>]]></content>
    
    
    <summary type="html">简述YUV和RGB视频像素格式。</summary>
    
    
    <content src="http://ww4.sinaimg.cn/large/61b57e82gw1fb2cstahfqj20zi0bzaak.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="Codec" scheme="https://www.freehacker.cn/tags/Codec/"/>
    
  </entry>
  
  <entry>
    <title>色彩</title>
    <link href="https://www.freehacker.cn/comm/color/"/>
    <id>https://www.freehacker.cn/comm/color/</id>
    <published>2017-10-22T16:24:27.000Z</published>
    <updated>2021-02-24T12:01:17.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>赤橙黄绿青蓝紫，谁持彩练当空舞？</p></blockquote><p><strong>颜色</strong>或<strong>色彩</strong>是通过<a href="https://zh.wikipedia.org/wiki/%E7%9C%BC">眼</a>、<a href="https://zh.wikipedia.org/wiki/%E8%84%91">脑</a>和我们的生活经验所产生的一种对<a href="https://zh.wikipedia.org/wiki/%E5%85%89">光</a>的视觉效应。<a id="more"></a></p><h2 id="色彩定义"><a href="#色彩定义" class="headerlink" title="色彩定义"></a>色彩定义</h2><p>本文开头那句是维基百科对<a href="https://en.wikipedia.org/wiki/Color">色彩</a>的定义，直白来说就是：光给人的感觉。具体分为三个部分：</p><ul><li>光的属性：波粒二象性；</li><li>眼的成像：视网膜生理特性；</li><li>人的感觉：主观经验性。</li></ul><p>光的属性决定了色彩的物理特性，眼的成像决定了色彩的生理特性，人的感觉反映了色彩的心理特性。</p><h3 id="光的属性"><a href="#光的属性" class="headerlink" title="光的属性"></a>光的属性</h3><p>目前科学界得出的结论是：光具有波动性，也具有粒子性。可见光是由光的波动性决定，人眼可以感受到的波长范围一般是落在390到700nm，具体每个颜色对应的光频率和波长如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><a href="https://zh.wikipedia.org/wiki/%E9%A1%8F%E8%89%B2">颜色</a></th><th style="text-align:center"><a href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E7%8E%87">频率</a></th><th style="text-align:center"><a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%95%B7">波长</a></th></tr></thead><tbody><tr><td style="text-align:center"><strong>紫色</strong></td><td style="text-align:center">668–789THz</td><td style="text-align:center">380–450nm</td></tr><tr><td style="text-align:center"><strong>蓝色</strong></td><td style="text-align:center">631–668THz</td><td style="text-align:center">450–475nm</td></tr><tr><td style="text-align:center"><strong>青色</strong></td><td style="text-align:center">606–630THz</td><td style="text-align:center">476–495nm</td></tr><tr><td style="text-align:center"><strong>绿色</strong></td><td style="text-align:center">526–606THz</td><td style="text-align:center">495–570nm</td></tr><tr><td style="text-align:center"><strong>黄色</strong></td><td style="text-align:center">508–526THz</td><td style="text-align:center">570–590nm</td></tr><tr><td style="text-align:center"><strong>橙色</strong></td><td style="text-align:center">484–508THz</td><td style="text-align:center">590–620nm</td></tr><tr><td style="text-align:center"><strong>红色</strong></td><td style="text-align:center">400–484THz</td><td style="text-align:center">620–750nm</td></tr></tbody></table></div><p>可见光光谱在电磁谱中仅仅占据370nm的宽度，可见光光谱在电磁谱中的位置如下：</p><p><img src="../../assets/comm/spectrum.png"></p><p>到此，可以进一步的解决几个关键问题：</p><p>1、光谱中只有七种颜色，何来白色、黑色、灰色？</p><p>要回答这个问题，就要理解单色和混色。只包含一个波长的光源，被称为单色光源，然而大多数光源的光谱不是单色的，它们的光是由不同强度和波长的光混合组成的。可以将光谱中三原色的光：红色、蓝色和绿色按一定比例混合得到白光。光谱中所有可见光的混合也是白光。黑色、灰色也类似。</p><p>2、为什么有些物体是白色的，有些物体是黑色的？</p><p>这是由于该物体的物理特性决定的，一个反射所有波长的光的表面是白色的，而一个吸收所有波长的光的表面是黑色的，一个反射光色所处波长的表示是蓝色的。</p><h3 id="眼的成像"><a href="#眼的成像" class="headerlink" title="眼的成像"></a>眼的成像</h3><p>眼的成像由视网膜的生理特性决定，对视网膜有兴趣的可以参考维基百科<a href="https://en.wikipedia.org/wiki/Retina">Retina</a>。这里仅仅给出一个从相同色彩得出不同成像的例子。如下图：</p><p><img src="../../assets/comm/vision-liar.jpeg"></p><p>任意使用一个取色软件，你会发现A和B方格同为RGB(787878)。视网膜无法真实的反映光的原始特性。</p><h3 id="人的感觉"><a href="#人的感觉" class="headerlink" title="人的感觉"></a>人的感觉</h3><p>如果此时你Google以下“色彩 感觉”，你会发现大多都是色彩对人的感觉的影响。但事实上人处于不同的心理时期，对同样的色彩会得到不同的体验。譬如，心情愉悦时，我们会觉得某个色情比较明亮，然而同样的色彩在我们不开心时，却显得十分昏暗。这是因为经过视网膜成像后的色彩，仍然需要经过大脑的处理。而对于颜色，大脑的主观心理特性远胜于客观事实特性。这也导致了所谓的色彩心理学。</p><h2 id="色彩属性"><a href="#色彩属性" class="headerlink" title="色彩属性"></a>色彩属性</h2><p>不论任何色彩，都具有三个基本的性质，一般称为<code>色彩三要素</code>或<code>色彩三属性</code>：色相（Hue）、彩度（Chroma）、明度（Value）。</p><h3 id="色相"><a href="#色相" class="headerlink" title="色相"></a>色相</h3><p>色相（Hue），又被称为色调，是用来区分色彩的首要特征，即依据不同波长的光来界定色彩的名字，如红、橙、黄、绿、蓝、紫。当我们描述色彩时，最常用<code>色相</code>来沟通，产生共鸣。改变色相比同等程度改变饱和度或亮度感受到的色彩变化要更大，所以被称为颜色最重要的特征。</p><p><img src="../../assets/comm/color-hue.jpg"></p><p>色相的确切定义为颜色等效光谱峰值的位置。</p><p><img src="../../assets/comm/color-spectrum-hue.png"></p><h3 id="彩度"><a href="#彩度" class="headerlink" title="彩度"></a>彩度</h3><p>彩度（Chroma），又被称为饱和度（Saturation）、色彩浓度，用来表示色彩的纯粹度或饱和度。彩度的高低，是以色彩中某种纯色的比例来分辨比较的，所以某一色彩加入到其他色彩时，彩度就会降低。要比较不同色彩间的彩度时，必须以指定某种纯色当依据才能比较。</p><p><img src="../../assets/comm/color-chroma.jpg"></p><p>彩度确切的定义是颜色等效光谱分布集中于波峰（色相）的程度，越集中其含颜色越少，饱和度越高。</p><p><img src="../../assets/comm/color-spectrum-chroma.png"></p><h3 id="明度"><a href="#明度" class="headerlink" title="明度"></a>明度</h3><p>明度（Value），英文中又称为Brightness、Lightness、Luma，用来表示色彩明暗的程度。比如，纯黄色比纯绿色来得明亮，纯黄色是明亮度高的色彩，而纯绿色是明亮度略低的色彩。</p><p><img src="../../assets/comm/color-value.jpg"></p><p>可以在同一色相色彩，以加入白色来提高明度；加入黑色来降低明度的方式，产生一系列的色彩变化，如浅红、淡红、亮红、暗红，即使红色不同的明度变化。</p><p><img src="../../assets/comm/color-value-red.jpg"></p><p>明度的确切定义是颜色等效光谱各色相心理强度之和。</p><p><img src="../../assets/comm/color-spectrum-value.png"></p><h2 id="色彩体系"><a href="#色彩体系" class="headerlink" title="色彩体系"></a>色彩体系</h2><p>色彩体系就是按人的视觉特点，使用规定的标号系统，把色彩按一定规则排列。这里我们仅仅分析色彩模型和色貌模型。</p><h3 id="色彩模型"><a href="#色彩模型" class="headerlink" title="色彩模型"></a>色彩模型</h3><p><strong>色彩模型</strong>是描述使用一组值（通常使用三个、四个值或者<em>颜色成分</em>）表示<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E8%89%B2">颜色</a>方法的抽象数学模型。例如<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F">三原色光模式</a>（RGB） 和<a href="https://zh.wikipedia.org/wiki/%E5%8D%B0%E5%88%B7%E5%9B%9B%E5%88%86%E8%89%B2%E6%A8%A1%E5%BC%8F">印刷四分色模式</a>（CMYK） 都是色彩模型。色彩空间是色彩模型通过具体的映射函数的特定实现。</p><p>常用的色彩模型包含RGB、CMYK、HVS、HSL、YUV、YCbCr、YIQ等。RGB、CMYK是利用原色相混的比例表示的色彩模型；HVS、HSL、YUV、YCbCr、YIQ利用不同的概念表示的色彩模型。YUV、YCbCr、YIQ电视常用色彩模型，目前的大多数WebCam的输出图像也使用这种色彩模型。</p><p>1、RGB</p><p>RGB色彩模型包含三个分量：R（红）、G（绿）、B（蓝），是根据三原色制定的立方体直角坐标系色彩模型，是最常用的色彩模型。</p><p><img src="../../assets/comm/color-model-rgb.jpg"></p><p>2、CMYK</p><p>CMYK色彩模型包含四个分量：C（青）、M（洋红）、Y（黄）、K（黑），是根据反射光的减色原理制度的模型，主要用于印刷行业。</p><p><img src="../../assets/comm/color-model-cmyk.gif"></p><p>3、YUV、YCbCr、YIQ</p><p>YUV 是一种目的为把颜色的视觉亮度分离来建立的色彩空间，Y (Luminance) 代表颜色的视觉亮度，U、V 则是剩余的色彩分量。视觉亮度代表的是颜色在人实际感受的亮度，之所以不同是因为不同色相的颜色的视觉亮度是不同的，比如纯绿色和纯蓝色在人眼中纯绿色明显要亮很多。一般的 YUV 模型中红绿蓝的视觉亮度比是：0.299:0.587:0.114。</p><p><img src="../../assets/comm/color-model-luminance.png"></p><p>YCbCr 通常被当做 YUV 的另一种形式，相比 YUV， Cb 和 Cr 通道分别更向红、蓝偏移，而且通常进行压缩。YCbCr 常用在图像压缩领域，JPEG 图片内部的色彩空间就使用 YCbCr 模型。</p><p>YIQ 是另一种视觉亮度拆分模型，与 YUV 很相似，是 NTSC 彩色电视的标准。</p><p>三者的差别见下图：</p><p><img src="../../assets/comm/color-model-yuv.png"></p><h3 id="色貌模型"><a href="#色貌模型" class="headerlink" title="色貌模型"></a>色貌模型</h3><p>色彩模型反映的是客观的色彩表现，色貌模型反映的是经过人的主观心理感受后的色彩表现。所以一个色貌模型应该能描述和预测不同光照、不同背景、不同观察条件下物体的色貌（色相、饱和度、明度等）。有关色貌模型可以参见维基百科<a href="https://en.wikipedia.org/wiki/Color_appearance_model">Color appearance model</a>。</p><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2><p>色彩模型和色彩空间必须要有一个映射函数，才能够在实际中使用。通过映射函数，我们给色彩模型确切的定义，进而得到了色彩空间，譬如：Adobe RGB、sRGB、CIE XYZ。映射函数生成颜色的某个完全子集——色域，色域与色彩模型一起定义一个新的色彩空间。</p><p><strong>色域</strong>是对一种颜色进行编码的方法，也指一个技术系统能够产生的颜色的总和。色域越大表示该色彩空间能够显示的颜色更多。</p><h3 id="基于RGB色彩模型的色彩空间"><a href="#基于RGB色彩模型的色彩空间" class="headerlink" title="基于RGB色彩模型的色彩空间"></a>基于RGB色彩模型的色彩空间</h3><p>RGB色彩空间包含：Adobe RGB、sRGB、Apple RGB、ProPhoto RGB等，它们都是RGB色彩模式，经过特定的映射函数，生成的绝对RGB色彩空间。</p><p>下图反映的是不同RGB色彩空间色域的对比，Horseshoe Shape of Visible Color表示人眼可辩视色域：</p><ul><li><a href="https://en.wikipedia.org/wiki/SRGB">sRGB</a>为了适应更多的设备，是常用色彩空间中色域最小的色彩空间；</li><li><a href="https://en.wikipedia.org/wiki/Adobe_RGB_color_space">Adobe RGB</a>的开发目的是为了尽可能在<a href="https://zh.wikipedia.org/wiki/CMYK">CMYK</a><a href="https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%89%B2%E5%8D%B0%E5%88%B7">彩色印刷</a>中利用计算机显示器等设备的<a href="https://zh.wikipedia.org/wiki/RGB">RGB</a>颜色模式上囊括更多的颜色，因此其色域较sRGB大很多，且完全包含sRGB色彩空间；</li><li><a href="https://en.wikipedia.org/wiki/ProPhoto_RGB_color_space">ProPhoto RGB</a>是为了摄像领域专门设计的，为满足摄像的需求，其拥有极大的色域，甚至包含眼不可辩视色域范围。</li></ul><p><img src="../../assets/comm/color-space.png"></p><h3 id="CIE-1931-XYZ色彩空间"><a href="#CIE-1931-XYZ色彩空间" class="headerlink" title="CIE 1931 XYZ色彩空间"></a>CIE 1931 XYZ色彩空间</h3><p>CIE色彩空间的设计目的是构建一个可以描述和排列所有色彩的系统，采用数学方式来定义的色彩空间。CIE色彩空间利用视觉的三色刺激值的匹配实验得到色彩空间。更精确地说，首先先定义三种主要颜色（primary color），再利用颜色叠加模型，即可叙述各种颜色。在三色加色法模型中，如果某一种颜色和另一种混合了不同分量的三种原色的颜色，均使人类看上去是相同的话，我们把这三种原色的分量称作该颜色的三色刺激值。</p><p>CIE 1931 RGB色彩空间是基于RGB色彩模型的色彩空间，其使用RGB三原色作为三种主要颜色，然而使用实现中的三种颜色匹配出所有颜色，会导致CIE 1931 RGB 色彩空间里颜色的值出现了负数。因此在此基础上，CIE组织有提出了CIE 1931 XYZ色彩空间。</p><p><img src="../../assets/comm/cie1931-rgxy.png"></p><p><a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">CIE 1931 XYZ</a>色彩空间定义三种现实中不存在的理想颜色作为三原色，通过数学变换将负的颜色分辨变为正的。具体的变化公式可以参考维基百科中描述。</p><p><img src="../../assets/comm/cie1931-xy.png"></p><p>CIE 1931 XYZ色彩空间是特殊的，因为它是基于人类<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E8%89%B2%E8%A7%86%E8%A7%89">颜色视觉</a>的直接测定，并充当很多其他色彩空间的定义基础。</p><ul><li><a href="https://en.wikipedia.org/wiki/SRGB">sRGB</a>给出了从CIE xyY或者CIE XYZ到sRGB的变换；</li><li><a href="https://en.wikipedia.org/wiki/Adobe_RGB_color_space">Adobe RGB</a>给出了从CIE xyY或者CIE XYZ到Adobe RGB的变换。</li></ul><h3 id="基于YUV色彩模型的色彩空间"><a href="#基于YUV色彩模型的色彩空间" class="headerlink" title="基于YUV色彩模型的色彩空间"></a>基于YUV色彩模型的色彩空间</h3><p>YUV色彩空间主要用来表示电视信号。</p><p>在现代彩色电视系统中，通常采用三管彩色摄像机或彩色CCD(点耦合器件)摄像机，它把摄得的彩色图像信号，经分色、分别放大校正得到RGB，再经过矩阵变换电路得到亮度信号Y和两个色差信号R－Y、B－Y， 最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这就是我们常用的YUV色彩空间。</p><p>采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量， 那么这样表示的图就是黑白灰度图。</p><h2 id="色彩量化"><a href="#色彩量化" class="headerlink" title="色彩量化"></a>色彩量化</h2><p>sRGB和Adobe RGB色彩空间都可以根据CIE 1931 XYZ色彩空间为基准来计算。对于CIE 1931 XYZ色彩空间中的某个颜色[1, 1, 1]，如下图：</p><p><img src="../../assets/comm/cie1931-xy111.png"></p><p>其对应的各个色彩空间分量值如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">色彩空间</th><th style="text-align:center">分量1</th><th style="text-align:center">分量2</th><th style="text-align:center">分量3</th><th style="text-align:center">分量4</th></tr></thead><tbody><tr><td style="text-align:center">sRGB</td><td style="text-align:center">28.6</td><td style="text-align:center">24.6</td><td style="text-align:center">23.9</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Adobe RGB</td><td style="text-align:center">33.2</td><td style="text-align:center">30.7</td><td style="text-align:center">30.1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CMY</td><td style="text-align:center">88.6%</td><td style="text-align:center">90.2%</td><td style="text-align:center">90.6%</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CMYK</td><td style="text-align:center">0%</td><td style="text-align:center">13.8%</td><td style="text-align:center">17.2%</td><td style="text-align:center">88.6%</td></tr><tr><td style="text-align:center">Lab</td><td style="text-align:center">8.99</td><td style="text-align:center">1.84</td><td style="text-align:center">1.21</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LCH</td><td style="text-align:center">8.99</td><td style="text-align:center">2.2</td><td style="text-align:center">33.23°</td></tr></tbody></table></div><p>对于sRGB和Adobe RGB计算出来的分量实际是[0,1]区间的值，一个分量采用8位量化精度，也就是将计算出来的值乘以255然后取整，就得到我们通常所见的RGB[0~255, 0~255, 0~255]表示的色彩值。</p><p>通过上表的比较，我们会发现sRGB和Adobe RGB相同的RGB分量值表示的颜色其实是不同的。这是一个困惑我很久的问题——虽然sRGB和Adobe RGB都可以使用RGB24来表示，但同样的值表示的颜色并不相同，也就是Adobe RGB能够使用RGB24 16777216个精度值表示更多的颜色，而sRGB值能表示更少的颜色。</p><p>有关RGB和YUV相关的知识，请参考<a href="http://www.freehacker.cn/media/codec-yuv-rgb/">视频像素格式</a>一文。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://styletin.com/archives/535">UI 设计知识库 [01] 色彩 · 理论</a></li><li><a href="https://en.wikipedia.org/wiki/Color_space">Color space</a></li><li><a href="http://www.colortell.com/rgbto">RGB颜色表转换</a></li></ul>]]></content>
    
    
    <summary type="html">颜色或色彩是通过眼、脑和我们的生活经验所产生的一种对光的视觉效应。</summary>
    
    
    <content src="http://wx4.sinaimg.cn/large/61b57e82gy1fkrweltnifj21gs0i2462.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="AuVi" scheme="https://www.freehacker.cn/tags/AuVi/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC拥塞控制策略</title>
    <link href="https://www.freehacker.cn/comm/webrtc-gcc/"/>
    <id>https://www.freehacker.cn/comm/webrtc-gcc/</id>
    <published>2017-09-05T13:58:17.000Z</published>
    <updated>2021-02-24T11:56:35.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你只是看起来很努力。</p></blockquote><p>影响视频会议质量的因素主要在于<code>视频图像质量</code>和<code>传输时延</code>。视频图像质量对于视频会议的影响不在此赘述。视频会议等实时流媒体应用对于实时性的要求很高，实时性要求我们必须要有较低的时延（<code>时延敏感</code>）。<a id="more"></a>影响时延的因素包含：</p><ul><li>媒体数据在收发端的处理速度</li><li>网络拥塞</li></ul><p>网络拥塞是本文的研究重点，TCP协议拥有完善的拥塞控制机制，UDP则没有在拥塞控制方面有所规定。由于目前大多实时流媒体应用都是基于UDP传输，所以高效的拥塞控制算法是保证实时流媒体应用QoS的重要手段。</p><blockquote><p>基于丢包的TCP协议无法满足实时流媒体应用的低时延需求。</p></blockquote><p>WebRTC里针对拥塞控制，采用了谷歌拥塞控制算法（Google Congestion Control，GCC），该算法包含两部分：发送端基于丢包的码率控制和接收端基于延迟的码率控制。这两种部分都是通过调节数据发送端码率来达到拥塞控制的目的。GCC算法架构如下：</p><p><img src="../../assets/comm/webrtc-gcc.png" alt="GCC Architecture" width=700></p><h2 id="发送端基于丢包的码率控制"><a href="#发送端基于丢包的码率控制" class="headerlink" title="发送端基于丢包的码率控制"></a>发送端基于丢包的码率控制</h2><p>发送端的码率控制是根据丢包率来计算预期的发送码率，丢包率的信息包含在接收到的RTCP报告报文中。计算公式如下，其中 ${f}<em>{l}({t}</em>{k})$ 表示 ${t}<em>{k}$ 时刻的丢包率，${A}</em>{s}({t}<em>{k})$ 表示 ${t}</em>{k}$ 时刻发送端的码率：</p><p><img src="../../assets/comm/webrtc-loss-based-controller.png" alt="GCC Loss-based Controller" width=500></p><h2 id="接收端基于延迟的码率控制"><a href="#接收端基于延迟的码率控制" class="headerlink" title="接收端基于延迟的码率控制"></a>接收端基于延迟的码率控制</h2><p>发送端的码率控制是根据延迟来计算预期的发送码率，计算出来的码率信息会通过RTCP REMB报文反馈给发送端。计算公式如下，其中${t}<em>{i}$表示第$i$个视频帧被接收的时间，<code>η=1.05</code>，<code>α=0.85</code>，${R}</em>{r}({t}_{i})$ 表示接收端在最近500ms中测量的接收码率：</p><p><img src="../../assets/comm/webrtc-delay-based-controller.png" alt="GCC Delay-based Controller" width=380 ></p><p>如GCC算法结构图所示，基于延迟的码率控制包含五个模块：Arrival-time Filter、Overuse Detector、Remote Rate Controller、Adaptive Threshold、Remb Processing。GCC论文中给出了这五个模块的关系：</p><blockquote><p>The remote rate controller is a finite state machine in which the state of $σ$ is changed by the signal $s$ produced by the over-use detector based on the output $m({t}<em>{i})$ of the arrival-time filter. The adaptive threshold block dynamically sets the threshold $γ({t}</em>{i})$ used by the over-use detector. The REMB Processing decides when to send a REMB message based on the value of the rate ${A}<em>{r}$. Finally, it is important to notice that ${A}</em>{r}({t}<em>{i})$ is upper bounded by 1.5${R}</em>{r}({t}_{i})$.</p></blockquote><h3 id="Arrival-time-Filter"><a href="#Arrival-time-Filter" class="headerlink" title="Arrival-time Filter"></a>Arrival-time Filter</h3><p>Arrival-time Filter模块用来计算网络延迟$m({t}<em>{i})$，GCC算法采用Kalman Filter来估算该值。Kalman Filter采用单程帧间延迟差值${d}</em>{m}({t}_{i})$，单程帧间延迟差值表示两个数据帧到达接收端的延迟差值。如下图所示：</p><p><img src="../../assets/comm/webrtc-one-way-delay-gradient-measurement.png" alt="GCC One Way Delay Gradient Measurement" width=500></p><p>根据该图，我们可以得出 ${d}<em>{m}({t}</em>{i})$ 的计算公式如下：</p><script type="math/tex; mode=display">{d}_{m}({t}_{i})={t}_{i}-{t}_{i-1})-({T}_{i}-{T}_{i-1})</script><h3 id="Overuse-Detector"><a href="#Overuse-Detector" class="headerlink" title="Overuse Detector"></a>Overuse Detector</h3><p>Overuse Detector根据Arrival-time Filter计算出的网络延时$m({t}<em>{i})$以及Adaptive Threshold提供的$γ({t}</em>{i})$值来判断当前网络是否过载，并告知Remote Rate Controller对应的信号$s$——<code>overuse</code>、<code>normal</code>、<code>underuse</code>。下图表明Overuse Detector是如何工作的：</p><p><img src="../../assets/comm/webrtc-overuse-detector-signalling.png" alt="GCC Overuse Detector Signalling" width=500></p><p>产生<code>overuse</code>、<code>normal</code>、<code>underuse</code>三种信号的条件如下：</p><ul><li>overuse: $m({t}<em>{i})$ &gt; $γ({t}</em>{i})$and keep 100ms</li><li>underuse: $m({t}<em>{i})$ &lt; -$γ({t}</em>{i})$ and keep 100ms</li><li>normal: -$γ({t}<em>{i})$ &lt; $m({t}</em>{i})$ &lt; $γ({t}_{i})$</li></ul><h3 id="Remote-Rate-Controller"><a href="#Remote-Rate-Controller" class="headerlink" title="Remote Rate Controller"></a>Remote Rate Controller</h3><p>Remote Rate Controller模块根据上文提到的接收端码率计算公式来计算接收端预估码率。该模块是个无线状态机，其状态变动如下图所示：</p><p><img src="../../assets/comm/webrtc-remote-rate-controller-fsm.png" alt="GCC Overuse Detector Signalling" width=500></p><p>结合上文中的公式，我们可以得出：</p><ul><li>当<code>s=overuse</code>，预估码率降低为接收码率的85%，处于<code>decrease</code>状态;</li><li>当<code>s=underuse</code>，预估码率保持和上次预估码率一样，处于<code>hold</code>状态；</li><li>当<code>s=normal</code>，预估码率上升为上次预估码率的105%，处于<code>increase</code>状态。</li></ul><h3 id="Adaptive-Threshold"><a href="#Adaptive-Threshold" class="headerlink" title="Adaptive Threshold"></a>Adaptive Threshold</h3><p>Adaptive Threshold模块用来使算法适应延迟变化的灵敏性。</p><h3 id="Remb-Processing"><a href="#Remb-Processing" class="headerlink" title="Remb Processing"></a>Remb Processing</h3><p>Remb Processing模块用于通知发送端来自接收端预估的码率。该码率通过RTCP REMB报文反馈给发送端。正常情况下，该报文每隔1s发送一次，但如果${A}<em>{r}({t}</em>{i})$ &lt; 0.97${A}<em>{r}({t}</em>{i-1})$，该报文立马发送。</p><h2 id="最终码率计算"><a href="#最终码率计算" class="headerlink" title="最终码率计算"></a>最终码率计算</h2><p>一旦发送端接收到RTCP报告报文，或是接收到携带接收端预估码率${A}<em>{r}$的REMB报文，发送端执行对应的码率控制算法——发送端根据发送端预估码率${A}</em>{s}({t}<em>{k})$、接收端预估${A}</em>{r}({t}<em>{k})$、最大允许码率${A}</em>{max}$最小允许码率${A}<em>{min}$，计算出最终的发送码率${R}</em>{s}({t}_{k})$。</p><script type="math/tex; mode=display">{R}_{s}({t}_{k})=max(min(min({A}_{s}({t}_{k}), {A}_{r}({t}_{k})), {A}_{max}), {A}_{min})</script><h2 id="WebRTC拥塞控制模块"><a href="#WebRTC拥塞控制模块" class="headerlink" title="WebRTC拥塞控制模块"></a>WebRTC拥塞控制模块</h2><p>WebRTC中实现了Google GCC算法，该实现包含发送端和接收端两部分。发送端负责发送端码率预估和计算最终目标码率；接收端负责接收端码率预估和统计丢包信息，并通过REMB报文和RTCP RR反馈给发送端。其总体模块图如下：</p><p><img src="../../assets/comm/webrtc-gcc-implementation.png" alt="WebRTC GCC Implementation" width=700></p><h3 id="远端比特率预估模块"><a href="#远端比特率预估模块" class="headerlink" title="远端比特率预估模块"></a>远端比特率预估模块</h3><p><img src="../../assets/comm/webrtc-gcc-remote-bitrate-caculate.png" alt="WebRTC GCC Remote Bitrate Calculate" width=1000></p><h3 id="本地比特率计算模块"><a href="#本地比特率计算模块" class="headerlink" title="本地比特率计算模块"></a>本地比特率计算模块</h3><p><img src="../../assets/comm/webrtc-gcc-local-bitrate-caculate.png" alt="WebRTC GCC Local Bitrate Calculate" width=1000></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf">Analysis and Design of the Google Congestion Control for Web Real-time Communication (WebRTC)</a></li></ul>]]></content>
    
    
    <summary type="html">Google Congestion Controller和WebRTC Bitrate Controller模块剖析。</summary>
    
    
    <content src="http://wx2.sinaimg.cn/large/61b57e82gy1fj91q7dx70j22r70xl76p.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="WebRTC" scheme="https://www.freehacker.cn/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>如何有效的管理项目中的共享代码</title>
    <link href="https://www.freehacker.cn/hacks/git-share-code/"/>
    <id>https://www.freehacker.cn/hacks/git-share-code/</id>
    <published>2017-08-28T14:10:40.000Z</published>
    <updated>2020-10-27T04:47:05.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人与人之间的交互是复杂的，并且其效果从来都难以预期，但却是工作中最为重要的方面。</p></blockquote><p>在很多大型项目中，需要在多个仓库中共享代码。这些代码可能是通信协议、公用代码库、第三方代码库等。如何管理共享代码是个头疼的问题，我们总不能在每个仓库中拷贝这些共享代码。git提供了submodule和subtree两种方案来方便我们管理。我们来进行对比，选择合适的方案加入到项目中。<a id="more"></a></p><h2 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h2><p>submodule是一个完全独立的仓库，引用submodule的父仓库和submodule的唯一联系，是保存在父仓库中子仓库某个<code>commit-SHA</code>值。我们通过在父仓库中执行<code>add</code>和<code>update</code>来增加和更新submodule。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test repository</span></span><br><span class="line">$ git submodule add git://github.com/sub/sub.git thirdparty/sub</span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>执行<code>add</code>操作后，在test目录下会产生一个<code>.gitsubmodule</code>文件，其内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitsubmodule</span><br><span class="line">[submodule <span class="string">&quot;sub&quot;</span>]</span><br><span class="line">    path = sub</span><br><span class="line">    url = git://github.com/sub/sub.git</span><br></pre></td></tr></table></figure><p>针对于频繁更新的共享代码仓库，submodule的缺陷在于其管理的复杂性。其复杂性体现在三个方面：</p><p>1、更新代码的复杂性</p><p>如果我们需要在submodule中提交代码，我们需要执行四步：1、切换到开发分支；2、pull最新代码；3、提交代码到submodule仓库；4、从父仓库中提交submodule当前<code>commit-SHA</code>值。切换到开发分支是很重要的，否则我们很可能会丢掉代码。同时，如果我们存在多个父仓库，每个父仓库都要提交submodule的当前<code>commit-SHA</code>值。</p><p>如果我们需要获取最新的submodule，我们需要执行两步：1、拉取父仓库代码；2、运行<code>git submodule update</code>命令。</p><p>2、团队协作的复杂性</p><p>在更新代码时，如果团队成员忘记其中的任何一步，对其他成员将会存在一定的影响。举两个例子：</p><blockquote><p>拉取最新代码时，如果我们忘记运行<code>git submodule update</code>命令，之后更新代码，很有可能在父仓库中提交了老的submodule<code>commit-SHA</code>值。</p><p>如果团队成员对子模块做了一个本地的变更，但没有推送到公共公共服务器，然后他们提交了一个指向那个非公共状态的<code>commit-SHA</code>值，并推送到了父项目所在仓库。这时，其他开发者试图运行<code>git submodule update</code>就会提示找不到所引用的子模块提交。</p></blockquote><p>3、代码合并的复杂性</p><p>在合并代码时，即使我们解决了submodule的冲突，还是需要执行<code>git submodule update</code>命令。</p><p>如果我们的共享代码仓库是稳定的第三方库，submodule是个极好的选择。然而，针对于频繁更新的共享代码仓库，使用submodule时无法避免其复杂性，但是可以通过一些手段，让我们不容易出错。</p><h2 id="git-submodule-trick"><a href="#git-submodule-trick" class="headerlink" title="git submodule trick"></a>git submodule trick</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><ul><li>master分支上作为submodule发布分支（开发分支遵循checkout/merge原则）</li><li>master分支上最新的提交必须可以被父仓库引用</li></ul><h3 id="初次clone"><a href="#初次clone" class="headerlink" title="初次clone"></a>初次clone</h3><p>使用<code>recursive</code>参数来自动clone submodule仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unpleasure method</span></span><br><span class="line">$ git <span class="built_in">clone</span> git://github.com/sub/sub.git</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># elegant method</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive git://github.com/sub/sub.git</span><br></pre></td></tr></table></figure><h3 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h3><p>使用<code>foreach</code>将所有submodule切换到master分支、拉取最新代码，然后在父仓库提交submodule的<code>commit-SHA</code>值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach --recursive git checkout master &amp;&amp; git pull</span><br><span class="line"><span class="comment"># you can changes submodule repository here.</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;update all submodule to latest commit id&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>当我们需要更新仓库中的submodule，<code>foreach</code>可以简化我们的工作量。</p><p>如果某些submodule并没有使用master分支作为发布分支，我们采用下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach -q --recursive \</span><br><span class="line">    <span class="string">&#x27;git checkout \</span></span><br><span class="line"><span class="string">        $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)&#x27;</span> &amp;&amp; \</span><br><span class="line">    `git pull`</span><br></pre></td></tr></table></figure><p>采用这个命令的前提是在添加submodule时指明分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add submodule to track master branch</span></span><br><span class="line">git submodule add -b master [URL to Git repo];</span><br><span class="line"></span><br><span class="line"><span class="comment"># update your submodule, and update code to the latest of branch master</span></span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>submodule代码会被多个父仓库引用，所以需要在每个父仓库中验证修改是否有效。在验证有效后，从开发分支merge到master分支。</p><h3 id="错误提交补救"><a href="#错误提交补救" class="headerlink" title="错误提交补救"></a>错误提交补救</h3><p>如果我们没有checkout master分支，却又提交了代码，可以使用<code>cherry-pick</code>命令提取错失的提交：</p><ul><li>执行<code>git checkout master</code>将HEAD从detached状态切换到master分支，记录git报出的warning中的<code>commit-SHA</code>；</li><li>执行<code>git cherry-pick commit-SHA</code>提取错失的提交到master分支；</li><li>执行<code>git push</code>重新提交代码。</li></ul><blockquote><p>如果需要提交代码，必须按照使用<code>foreach</code>指令，确保每个submodule都在正确的分支、最新的提交。如果出现本节这种情况，说明开发者没有执行正确的使用步骤。</p></blockquote><h2 id="git-subtree"><a href="#git-subtree" class="headerlink" title="git subtree"></a>git subtree</h2><p>subtree对于父仓库来说是完全透明的，所有开发人员看到的是一个项目中的普通目录，开发人员无须针对subtree做特殊的处理。只需要维护subtree的开发人员在合适的时候去执行代码同步操作。我们在父仓库中通过<code>add</code>、<code>push</code>和<code>pull</code>来操作subtree：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add -f sub git://github.com/sub/sub.git</span><br><span class="line">$ git subtree add --prefix=sub sub master --squash</span><br><span class="line">$ git subtree pull --prefix=sub sub master --squash</span><br><span class="line">$ git subtree push --prefix=sub sub master --squash</span><br></pre></td></tr></table></figure><p>subtree是git官方网站推荐使用的方案。subtree的优点在于简单，复杂度低。过于简单也是subtree的缺点：</p><ul><li>我们无法在subtree目录中查看对应的commit信息；</li><li>subtree的提交会污染父仓库的提交记录。</li></ul><blockquote><p>未完待续。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://codingkilledthecat.wordpress.com/2012/04/28/why-your-company-shouldnt-use-git-submodules/">Why your company shouldn’t use Git submodules</a></li></ul>]]></content>
    
    
    <summary type="html">本文着重分析git submodule和git subtree的使用细节和注意事项。</summary>
    
    
    <content src="http://ww1.sinaimg.cn/large/61b57e82gw1f5ydh2b6dgj20sg09smyh.jpg" type="image"/>
    
    
    <category term="Utility" scheme="https://www.freehacker.cn/categories/Utility/"/>
    
    
    <category term="Tools" scheme="https://www.freehacker.cn/tags/Tools/"/>
    
    <category term="Git" scheme="https://www.freehacker.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何在团队中避免重复</title>
    <link href="https://www.freehacker.cn/pragmatic/dry/"/>
    <id>https://www.freehacker.cn/pragmatic/dry/</id>
    <published>2017-08-04T15:24:55.000Z</published>
    <updated>2020-10-27T04:47:05.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>程序员修炼之道 提示11：DRY - Don’t Repeat Yourself.</p></blockquote><p>重复意味着糟糕、浪费。<a id="more"></a></p><h2 id="导致重复"><a href="#导致重复" class="headerlink" title="导致重复"></a>导致重复</h2><h3 id="管理者的魄力"><a href="#管理者的魄力" class="headerlink" title="管理者的魄力"></a>管理者的魄力</h3><p>管理者很有可能意识到重复的危害，却没有魄力去推动成员去落实。这是致命的。</p><h3 id="成员的无意识"><a href="#成员的无意识" class="headerlink" title="成员的无意识"></a>成员的无意识</h3><p>在一个团队中，团队成员很有可能没有意识到重复的可怕。或许有人会觉得，别人的代码写的很糟糕，自己需要再写一套；有人会觉得，使用别人的轮子，自己无法进步，还是自己造一套来得好；还有人会觉得，这都无所谓，尽快完成工作，我维护的模块没有问题就行了，用不着管自己是否与别人重复。</p><p>在一个团队中，团队成员可能意识到重复的可怕，却没有认识到可能潜伏重复的方方面面。譬如，面向对象设计中类接口中成员函数/数据成员功能的重复。</p><h2 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h2><h3 id="团队意识"><a href="#团队意识" class="headerlink" title="团队意识"></a>团队意识</h3><p>团队中成员需要坚持<code>以重复为耻，以复用为荣</code>的团队意识。团队意识落实到团队成员身上，具体表现如下：</p><ul><li>团队成员必须认识到：重复的危害、重复的内容、如何避免重复。</li><li>团队成员必须认识到公共库的重要性，对于可构建公共库的内容，需主动提出评审。</li><li>团队管理者在管理重复一事上，必须要有决心，不可容忍重复的出现。</li></ul><h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><p>除非很熟悉该段代码的逻辑，否则代码评审很难在较短时间内，发现代码逻辑上的问题。但为什么这里又要强调代码评审呢？</p><ul><li>代码评审督促代码撰写者写出更好地代码；</li><li>代码评审能够发现代码撰写者是否重复；</li><li>代码评审增加团队成员之间的交流，使复用的可能性增加。</li></ul><h3 id="避免注释"><a href="#避免注释" class="headerlink" title="避免注释"></a>避免注释</h3><p>注释是对代码的重复，如果代码可以做到自解释，则避免注释。</p><h3 id="构建公共库"><a href="#构建公共库" class="headerlink" title="构建公共库"></a>构建公共库</h3><p>1、评选出技术能力强、责任心强的团队成员负责管理公共库。</p><p>2、制定并遵守一套公共库构建原则</p><p>若公共库已经存在开源版本实现，且该实现经过同行复审、商业应用、存在开发者持续修复问题，则推荐直接使用该实现的稳定版本。在无合适的开源实现情况下，构建公共库需要遵守几个原则：</p><ul><li>公共库的构建必须紧随开发需求或技术规划，不可为了构建公共库而构建，公共库构建前必须经过评审。</li><li>公共库的构建与评审必须由有经验、技术能力强、代码风格好的成员来负责。</li><li>开发完成的公共库必须要经过完备的测试（譬如单元测试）才可应用到发布软件中。</li></ul><p>经开发并测试完成的公共库，可以使用nuget或conan来进行管理，方便团队成员使用。</p><p>3、重构糟糕的公共库</p><p>需要重构的公共库，一定是糟糕的公共库。糟糕的公共库很有可能给团队成员不好的体验，使用这样的公共库，大多数程序员都有自己重新写一套的冲动。发现糟糕的公共库，务必要第一时间安排人员重构。保证共同库使用者的良好体验，是一个公共库管理者的责任。</p><h2 id="必要的重复"><a href="#必要的重复" class="headerlink" title="必要的重复"></a>必要的重复</h2><p>文档是对代码的重复，但却也是不可或缺的。</p>]]></content>
    
    
    <summary type="html">总结软件团队中如何避免重复。</summary>
    
    
    <content src="http://wx1.sinaimg.cn/large/61b57e82gy1fd9wp28v5ij20zk0c2q5f.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Team" scheme="https://www.freehacker.cn/tags/Team/"/>
    
    <category term="Coding" scheme="https://www.freehacker.cn/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>多线程同步问题 - 条件变量和Event</title>
    <link href="https://www.freehacker.cn/foundation/cpp-thread-sync-event-condition_varaiable/"/>
    <id>https://www.freehacker.cn/foundation/cpp-thread-sync-event-condition_varaiable/</id>
    <published>2017-05-25T13:04:12.000Z</published>
    <updated>2020-10-27T04:47:05.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络是二十一世纪的图标。</p></blockquote><p>本文记录Poco::Condition使用过程中遇到的坑点，并且延伸到Windows Event和C++11中的std::condition_variable相关内容。<a id="more"></a></p><h2 id="Poco-Condition实现"><a href="#Poco-Condition实现" class="headerlink" title="Poco::Condition实现"></a>Poco::Condition实现</h2><p>首先让我们看看Poco::Condition中的wait/signal两个操作的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Mtx</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(Mtx&amp; mutex)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUnlock&lt;Mtx&gt; <span class="title">unlock</span><span class="params">(mutex, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    Event event;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FastMutex::ScopedLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">        enqueue(event);</span><br><span class="line">    &#125;</span><br><span class="line">    event.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Condition::signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FastMutex::ScopedLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!waitQueue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        waitQueue_.front()-&gt;<span class="built_in">set</span>();</span><br><span class="line">        dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Poco::Condition底层是基于Poco::Event来实现的，wait操作将Poco::Event对象加入到队列中，并等待其相应置位，signal操作从队列中pop出Poco::Event并置位，wait操作和signal操作通过FastMutex对象来保证对队列的互斥操作。</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>在程序中使用了Poco的Condition类，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Poco::Condition cond;</span><br><span class="line">Poco::Mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.lock();</span><br><span class="line">    cond.wait(mtx);</span><br><span class="line">    mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cond.signal();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread([]()&#123;</span><br><span class="line">        dosomething();</span><br><span class="line">        signal();</span><br><span class="line">    &#125;);</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于多线程执行顺序的不可预期性，上面的代码存在一定的概率会导致cond.signal操作调用之后，cond.wait才开始执行，导致cond.wait函数一直block。</p><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>我们按照linux下的条件变量的调用方法，将上述代码做一定的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Poco::Condition cond;</span><br><span class="line">Poco::Mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mtx.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cond.wait(mtx);</span><br><span class="line">    mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.lock();</span><br><span class="line">    cond.signal();</span><br><span class="line">    mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    <span class="built_in">std</span>::thread([]()&#123;</span><br><span class="line">        dosomething();</span><br><span class="line">        signal();</span><br><span class="line">    &#125;);</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使wait函数能够成功返回的最重要的一点是：要保证先执行wait函数，然后再执行signal函数。这个保证能够确保在cond.signal操作执行时，Poco::Condition的等待队列中一定会存在一个Poco::Event对象。只有队列中存在Poco::Event对象，cond.signal中的置位操作才会执行。</p><p>由于多线程执行顺序的不确定性，具体的函数执行顺序可能如下：</p><blockquote><p>wait函数中<code>enqueue(event)</code>执行完毕 → 切换时间片 → signal函数中<code>waitQueue_.front()-&gt;set()</code>执行完毕 → wait函数中<code>event.wait()</code>开始执行。</p></blockquote><p>这个时候面临另外一个问题：在Poco::Event对象置位时，该对象可能并没有处于wait状态，那么此时，会不会遗漏该置位请求，导致cond.wait操作卡死？由于Poco::Event在Windows下的实现就是基于Event，所以翻译过来就是：如果Event对象调用<code>setEvent</code>或<code>PulseEvent</code>时，此时并没有线程<code>WaitForSingleObject</code>等待该Event置位，这个<code>setEvent</code>或<code>PulseEvent</code>请求会不会遗失掉？事实是不会的，在Event对象被置位后，调用<code>WaitForSingleObject</code>函数时会立即返回的。</p><h2 id="Event的置位请求有没有可能丢失？"><a href="#Event的置位请求有没有可能丢失？" class="headerlink" title="Event的置位请求有没有可能丢失？"></a>Event的置位请求有没有可能丢失？</h2><p>在《Win32多线程编程》一书中有说到：</p><blockquote><p>要求苏醒的请求并不会被存储起来，可能会遗失掉。如果一个AutoReset event对象调用SetEvent或PulseEvent，而此时并没有线程在等待，这个event会被遗失。如Wait…()函数还没来得及调用就发生了Context Switch，这个时候SetEvent，这个要求苏醒的请求会被遗失，然后调用Wait…()函数线程卡死。</p></blockquote><p>我一直以为事实就是如此，不过代码证明结果并不是这样的，看看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line">HANDLE ghWriteEvent;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ghWriteEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, TEXT(<span class="string">&quot;WriteEvent&quot;</span>));</span><br><span class="line">    SetEvent(ghWriteEvent);</span><br><span class="line">    DWORD dwWaitResult = WaitForSingleObject(ghWriteEvent, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不会卡死在WaitForSingleObject函数，该函数会立即返回。因此采用上文中修改后的代码能够解决Poco::Condition存在的问题，虽然不如直接使用Poco::Event优雅。</p><h2 id="std-condition-variable的notify请求有没有可能丢失？"><a href="#std-condition-variable的notify请求有没有可能丢失？" class="headerlink" title="std::condition_variable的notify请求有没有可能丢失？"></a>std::condition_variable的notify请求有没有可能丢失？</h2><p>我们现在可以确定Event的置位请求不会丢失，那么std::condition_variable的notify请求会不会丢失呢？我们来看一段简单的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line">cv.notify_one();</span><br><span class="line"><span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">cv.wait(lck);</span><br></pre></td></tr></table></figure><p>执行这段代码会发现，cv.wait操作会block。目前还没有深入了解condition_variable的底层实现，具体原因未知。不过可以找到不少方案保证cv.notify_one操作执行之前，cv.wait操作一定已经执行。譬如增加标志位，标志notify_one操作是否已经执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_id</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">    <span class="keyword">while</span> (!ready) cv.wait(lck);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.notify_all();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) threads[i] = <span class="built_in">std</span>::thread(do_print_id, i);</span><br><span class="line">    go();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《C++并发编程》一书中给出了另外一个例子，使用std::condition_variable的wait操作的第二个版本来解决该问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;  </span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare())</span><br><span class="line">    &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.push(data);  </span><br><span class="line">        data_cond.notify_one();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(</span><br><span class="line">            lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);  </span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，wait()会去检查这些条件(通过调用所提供的lambda函数)，当条件满足(lambda函数返回true)时返回。如果条件不满足(lambda函数返回false)，wait()函数将解锁互斥量，并且将这个线程(上段提到的处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠状态中苏醒，重新获取互斥锁，并且对条件再次检查，在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并且重新开始等待。</p><p>必须通过额外的辅助条件才能很好地利用条件变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Poco库的使用还是存在不少坑点，只有踩坑之后才能更好的掌握。同时，对于过去掌握的知识点，一定不能轻信，书本的内容也可能存在错误，有机会自己写点demo，验证所学习的内容。</p><p>Event和std::condition_variable对于置位/notify请求的处理是不一样的。这在平时使用的时候需要注意。</p>]]></content>
    
    
    <summary type="html">线程同步相关踩坑记录。</summary>
    
    
    <content src="http://ww1.sinaimg.cn/large/61b57e82gw1f2ro2bxcqjj21gs0i2wlw.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="CPlusPlus" scheme="https://www.freehacker.cn/tags/CPlusPlus/"/>
    
    <category term="Thread" scheme="https://www.freehacker.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>概念</title>
    <link href="https://www.freehacker.cn/republic/concept/"/>
    <id>https://www.freehacker.cn/republic/concept/</id>
    <published>2017-05-23T11:24:55.000Z</published>
    <updated>2020-10-27T04:47:05.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于必须决定控制的工作，仍然采用可靠地老式钟控系统。<br>在需要终极适应性的地方，你所需要的是失控的群件。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5">概念</a>在维基百科中的定义是：<em>概念是人类对一个复杂的过程或事物的理解。从哲学的观念来说概念是思维的基本单位。</em><a id="more"></a>概念不清晰导致思维不清晰。</p><h2 id="横向-VS-纵向"><a href="#横向-VS-纵向" class="headerlink" title="横向 VS 纵向"></a>横向 VS 纵向</h2><p>横向比较是对空间上同时并存的事物的既定形态进行比较。是对多种相关事物的同层次的比较，可以了解同类事物的大小、多少、优劣，以对决策起到参考作用</p><p>纵向比较是指单个事物与过去某个时间的状态进行比较，即时间上的比较。比较同一事物在不同时期的形态，从而认识事物的发展变化过程，揭示事物的发展规律。</p><p>知乎回答：</p><blockquote><p>横向对比是相对平行概念的相关内容对比，而纵向对比是在事物本身的不同深度（或者维度）的分析。比如我们讨论中国经济是否应该转型，在数据比较时横向对比就是其他国家经济构架和经济状况，而纵向对比就是找中国经济一段时间内的变化，比如78年/88年/98年/08年，分析趋势。</p></blockquote><h2 id="横向扩展与纵向扩展"><a href="#横向扩展与纵向扩展" class="headerlink" title="横向扩展与纵向扩展"></a>横向扩展与纵向扩展</h2><ul><li><code>横向扩展</code> 也叫 <code>水平扩展</code>，用更多的节点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作</li><li><code>纵向扩展</code> 又叫 <code>垂直扩展</code>，扩展一个点的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车</li></ul><h2 id="Proxy-VS-Agent"><a href="#Proxy-VS-Agent" class="headerlink" title="Proxy VS Agent"></a>Proxy VS Agent</h2><p>Proxy和Agent都可翻译为代理，二者的区别主要在于：</p><ul><li>Proxy面向所有客户，Proxy负责代理服务提供商的某些服务（可以是某一服务提供商的所有服务，也可以是多个服务提供商的某些服务），其对应的是服务供应商具体服务。一个Proxy所代理的服务可提供给所有的客户，提供同样服务的Proxy不需要存在多个；</li><li>Agent面向唯一客户，Agent负责代理服务提供商的所有服务（对于客户来说，Agent就是服务提供商，Agent必须满足客户的所有需求），其对应的是服务供应商这个整体。一个Agent所代理的服务仅提供给唯一的客户，如果需要提供给多个客户类似的服务则需要多个Agent。</li></ul><p>针对Proxy和Agent可以举两个例子：</p><p>1、商业组织</p><p>Agent被称为商业代理，譬如银河集团大中华区总代理（<em>General agent of Greater China</em>）就是Agent，其面向的是大中华区这唯一客户，其代理的是银河集团；大中华区总代理并不为新马泰区提供服务，如果需要为新马泰区提供服务，则必须要建立新马泰区总代理。</p><p>Proxy被称为中转代理，电信客服部门类似于Proxy，电信客服部门往往只存在一个，可以代理电信公司多个其他部门的服务，并面向于所有的客户。电信部门中的客服人员类似于Agent，客服和客户是一对一服务，其代理电信公司的所有服务。</p><p>2、程序开发</p><p>Proxy被称为代理服务器、网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。形象的说：它是网络信息的中转站。譬如客户端代理服务器（ClientProxy），其可以为所有的客户端提供服务，并且其同时可以提供登录服务、鉴权服务、资源操作服务等。</p><p>Agent被称为用户代理，譬如SQL Server Agent。SQL Server Agent使用 SQL Server 来存储作业信息。 作业包含一个或多个作业步骤。 每个步骤都有自己的任务。例如，备份数据库。SQL Server Agent所代理的SQL Server只提供给当前客户（计算机），每个客户（计算机）都有自己的SQL Server Agent。</p>]]></content>
    
    
    <summary type="html">追求最清晰明了的思维模式。</summary>
    
    
    <content src="http://wx3.sinaimg.cn/large/61b57e82gy1ffwn7rwuzyj21hc0imads.jpg" type="image"/>
    
    
    <category term="TimeCapsule" scheme="https://www.freehacker.cn/categories/TimeCapsule/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Windows共享网络热点开发</title>
    <link href="https://www.freehacker.cn/platform/win-wifi/"/>
    <id>https://www.freehacker.cn/platform/win-wifi/</id>
    <published>2017-05-03T11:53:26.000Z</published>
    <updated>2020-10-27T04:47:05.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>思考比工具更重要，发挥才智远优于理性，行动比分析更为迫切。</p></blockquote><p>市面上WiFi热点软件竞争激烈，猎豹WiFi、360WiFi、WiFi共享精灵等等产品在WiFi热点方面已经做得很成熟。但这总是其他人家的产品，对于一个新手来说，如何很快的开发出一款稳定的WiFi热点产品呢？基于分享互助的观点，这里将自己从事WiFi热点开发的经验写成博文。<a id="more"></a></p><h2 id="几个基本知识点"><a href="#几个基本知识点" class="headerlink" title="几个基本知识点"></a>几个基本知识点</h2><p>开发一款WiFi热点软件需要知道哪些知识？我们先来看看这几个基本知识点，帮助我们更快的上手。</p><h3 id="Windows无线承载网络"><a href="#Windows无线承载网络" class="headerlink" title="Windows无线承载网络"></a>Windows无线承载网络</h3><p>如果不需要连接外部网络的功能，实现Windows无线承载网络，就已经实现了一款WiFi热点软件了。多简单，从百度上搜搜别人博客上实现的代码，从谷歌上搜搜开源的代码——有一个C#开源项目已经实现该功能。的确很简单，不过即使是不需要连接外部网络，这点实现也是不够的。</p><h3 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a>ICS</h3><p>Internet Connection Sharing，网络连接共享，为WiFi热点提供连接外部热点的功能。大多数人使用WiFi热点软件，主要就是为了方便移动设备连接网络。</p><blockquote><p>MSDN的Native WiFi一节给出了Windows无线承载网络和ICS的详尽讲解，读懂了这里的讲解，也就能实现最简单的WiFi热点功能。</p></blockquote><p>为什么说是最简单的呢？那是因为你还会遇到下面问题：</p><ul><li>你可能开启不了热点</li><li>移动端可能连接不上该热点</li><li>移动端连接上了却没法上网</li><li>连接上了一直掉线</li><li>…</li></ul><p>这些问题，都会在本文后面给出解决方案或者原因分析——解决不了呀。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>ICS提供了基本的DHCP功能，不过千万不要太指望它，我们还是老老实实的自己实现一个DHCP服务。DHCP协议内容，网络上很多，开源的DHCP服务器代码不稳定，自己实现DHCP服务更能保证正确性。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT，Network Address Translator，网络地址转换，主要作用是把内网IP地址转换成为全球唯一的可定位的外部IP地址，从而使得局域网内的所有用户可以通过一个或者少数几个IP地址与全球的Internet通信——不仅节约了IP地址，而且在一定程度上保护了内部网络。</p><p>我们这儿使用NAT也是为了提供一个类似ICS的功能，实际上微软的ICS也是简版的NAT。</p><h2 id="基本的网络共享功能开发"><a href="#基本的网络共享功能开发" class="headerlink" title="基本的网络共享功能开发"></a>基本的网络共享功能开发</h2><p>Windows无线承载网络提供最基本的网络共享功能，然而由于未加入ICS/NAT，这里仅仅是一个局域网络，实现这个基本功能，我们仍然是不能使用其来连接外网的。可是实现这一步也是必须的一步。</p><h3 id="启动前准备"><a href="#启动前准备" class="headerlink" title="启动前准备"></a>启动前准备</h3><p>在启动无线承载网络之前，需要有一些准备步骤，用来确定当前系统环境适合无线承载网络的启动。</p><blockquote><p>这些准备步骤是重中之重，如果没有这些准备步骤，启动失败的概率会大大提高。</p></blockquote><p>启动前准备一：开启无线承载网络所需服务，这些服务有可能会被关闭，必须要主动检测服务是否正常运行。具体服务包括：</p><ul><li>Winmgmt</li><li>ALG</li><li>BFE</li><li>Wlansvc</li><li>MpsSvc</li><li>iphlpsvc</li><li>dot3svc</li><li>WwanSvc</li><li>SharedAccess</li><li>WZCSVC</li></ul><p>启动前准备二：启动DHCP服务，并检测服务是否正常运行。DHCP服务后文会提及。</p><p>启动前准备三：判断是否存在无线网卡，如果没有无线网卡，网络共享功能只是空谈。</p><p>启动前准备四：检测无线网卡是否支持无限承载网络。</p><p>启动前准备五：检测无线网卡是否被禁用，如果被禁用就重启。</p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>基本功能的实现主要依赖于对MSDN相关文档的深入阅读，本节不会翻译这篇文章，本节的重点是基本功能实现的调用流程。</p><blockquote><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd815252">MSDN: Using Wireless Hosted Network and Internet Connection Sharing</a></p></blockquote><p>调用流程一：初始化无线承载网络信息。</p><ul><li>设置无线承载网络可开启：调用WlanHostedNetworkSetProperty函数设置wlan_hosted_network_opcode_enable属性为TRUE；</li><li>设置无线承载网络基本信息：调用WlanHostedNetworkSetProperty函数设置wlan_hosted_network_opcode_connection_settings属性，需要设置SSID、连接用户数；</li><li>设置密码键值：调用WlanHostedNetworkSetSecondaryKey设置密码信息</li></ul><p>调用流程二：启动无线承载网络。</p><ul><li>关闭已经启动的无线承载网络：调用WlanHostedNetworkForceStop函数；</li><li>启动无线承载网络：调用WlanHostedNetworkStartUsing函数；</li><li>保存无线承载网络GUID信息：调用WlanHostedNetworkQueryStatus函数获取PWLAN_HOSTED_NETWORK_STATUS信息中的IPDeviceID值</li></ul><p>调用流程三：启动失败自修复。</p><ul><li>使用SetupAPI禁用设备并重新打开设备：这段可能需要百度/谷歌/MSDN寻找SetupAPI的使用方法，有可能需要多次禁用和启动，直到网络状态非wlan_hosted_network_unavailable；</li><li>重新启动无线承载网络</li></ul><p>上述流程没有涉及到具体代码的撰写，主要阐述需要调用的函数和操作。</p><h2 id="DHCP-1"><a href="#DHCP-1" class="headerlink" title="DHCP"></a>DHCP</h2><p>在启动无限承载网络后，如果这时用手机连接热点，会发现手机无线网络一直都卡在获取IP地址的地方。这是因为这个时候无线承载网络并没有提供DHCP功能——ICS能够提供该功能，如果已经开启ICS，是能够获取到IP的，缺陷是不稳定，很有可能无法分配IP。</p><p>所以就需要我们自己实现一个DHCP服务，Google一下你就会发现不少开源的服务，选择一个仔细调试。否则你很有可能被这个水土不服的家伙坑了。你必须要了解DHCP的原理、能够分析抓包获取的数据。（推荐博文<a href="http://blog.163.com/hlz_2599/blog/static/14237847420134139541993/">DHCP协议原理及报文分析  </a>以及<a href="https://wenku.baidu.com/view/7aee72277375a417866f8fe6.html">DHCP报文精细分析_加上wireshark抓包</a>）</p><p>DHCP服务需要绑定一个静态IP，这个静态IP的设定必须要正确。可以设置一个IP库，防止IP和主机IP冲突。具体静态IP的设置方法，可以通过命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netsh interface ip <span class="built_in">set</span> address ..。</span><br></pre></td></tr></table></figure><p>不过这个设置是需要找到对于那个的无限承载网络命名信息，这个信息定义在”SYSTEM\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\{GUID Get Before}\Connection”下。</p><p>DHCP实现的最终效果要能满足下面需求：</p><ul><li>无线承载网络开启时，能够给移动端快速的分配IP地址；</li><li>不能影响电脑本身所在局域网中的DHCP服务；</li><li>不能导致IP分配冲突</li></ul><h2 id="ICS-1"><a href="#ICS-1" class="headerlink" title="ICS"></a>ICS</h2><p>Windows通过ICS提供基本的网络共享功能。ICS共享网络的流程如下：</p><ul><li>通过获取HostedNetwork接口GUID</li><li>获取外网接口GUID，需要判断该网络是否能够连接外部网络</li><li>通过调用EnableSharing开启ICS网络共享</li></ul><h2 id="NAT-1"><a href="#NAT-1" class="headerlink" title="NAT"></a>NAT</h2><p>首先，我们需要知道NAT的原理，具体参考<a href="http://www.cnblogs.com/bo083/articles/2170189.html">NAT原理与NAT穿越</a>。</p><p>然后，需要对中间层驱动有一定的了解。参考下列文献：</p><ul><li><a href="http://www.xfocus.net/articles/200307/568.html">基于IMD的包过滤防火墙原理与实现</a></li><li><a href="https://wenku.baidu.com/view/3ae23920915f804d2b16c12c.html">基于PassThru的NDIS中间层驱动程序扩展1</a></li><li><a href="http://bbs.pediy.com/thread-191434.htm">如何把NDIS Filter框架利用到日常的Windows驱动开发工作中</a></li><li><a href="http://blog.csdn.net/yxyhack/article/details/6060999">NDIS中间层的驱动包截获技术教程</a></li><li><a href="http://www.xfocus.net/articles/200605/865.html">基于PassThru的NDIS中间层驱动程序扩展</a></li><li><a href="http://bbs.pediy.com/thread-137545.htm">NDIS中间层驱动开发在Win7系统下和Windows XP系统下的区别</a></li><li><a href="http://www.xfocus.net/articles/200606/870.html">NAT在NDIS中间层驱动中的实现</a></li><li><a href="http://www.cnblogs.com/wubiyu/archive/2008/08/01/1257801.html">NDIS开发[网络驱动开发]</a></li><li><a href="http://www.cnblogs.com/LittleHann/p/4844874.html">Windows网络驱动、NDIS驱动(微端口驱动、中间层驱动、协议驱动)、TDI驱动(网络传输层过滤)、WFP(Windows Filtering Platform)</a></li><li><a href="http://bbs.csdn.net/topics/348555">用NDIS中的passthru实现NAT的若干问题</a></li></ul><p>这一块的代码我也只实现了一半，仅列出参考的一些文献。</p><h2 id="一些难以解决的问题"><a href="#一些难以解决的问题" class="headerlink" title="一些难以解决的问题"></a>一些难以解决的问题</h2><p>最重要的问题就是稳定性问题，经过多方求证，目前主要和系统以及无线网卡驱动有关。此问题暂时不可解。</p><h2 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h2><p>下面是一些有用的链接，帮助我们完成可能存在的额外工作：</p><ul><li><a href="http://stackoverflow.com/questions/31249684/how-to-change-the-network-name-shown-in-windowss-ncpa-cpl-using-c">How to change the Network name shown in Windows’s ncpa.cpl using C++?</a></li><li><a href="http://bbs.csdn.net/topics/390864539/">如何判断网卡是有线网卡还是无线网卡</a></li><li><a href="https://superuser.com/questions/618908/how-does-windows-know-which-network-adapter-is-a-wireless-device">How does Windows know which network adapter is a wireless device?</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/network/configuring-an-inf-file-for-a-modifying-filter-driver">Configuring an INF File for a Modifying Filter Driver</a></li><li><a href="http://blog.csdn.net/woshinia/article/details/10631483">寻找正在连接中的网络连接，并开启网络连接的网络连接共享功能</a></li></ul>]]></content>
    
    
    <summary type="html">无线承载网络是Windows7和之后的操作系统所支持的新特性，其主要是实现物理网卡虚拟化和软件AP。本文主要基于Native Wifi Api来简述无线网络热点的实现。</summary>
    
    
    <content src="http://ww4.sinaimg.cn/large/61b57e82gw1f74zpzj8bmj21gs0i2gol.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Platform" scheme="https://www.freehacker.cn/tags/Platform/"/>
    
    <category term="Win32" scheme="https://www.freehacker.cn/tags/Win32/"/>
    
  </entry>
  
  <entry>
    <title>视频像素格式YUV和RGB</title>
    <link href="https://www.freehacker.cn/comm/codec-yuv-rgb/"/>
    <id>https://www.freehacker.cn/comm/codec-yuv-rgb/</id>
    <published>2017-04-23T06:33:54.000Z</published>
    <updated>2021-02-24T12:01:39.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失控</p></blockquote><p>黑白图像的每个像素只需要一个幅值表示其亮度即可，而彩色图像的每个像素至少需要三个值来表示其亮度和色度。所谓色彩空间就是表示彩色图像的亮度与色度的方法。常见的色彩空间包含RGB和YUV色彩空间，每个色彩空间通过不同的像素格式来存储图像。<a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>像素格式描述了像素数据存储所用的格式，定义了像素在内存中的编码方式。YUV和RGB为两种经常使用的像素格式。</p><p>RGB和YUV都是像素颜色编码方法，用于表示颜色，两者可以相互转化。<a href="http://www.fourcc.org/">FOURCC</a>网站给出了RGB和YUV两种格式的详细技术指南。</p><blockquote><p>FourCC：Four-Character Codes，代表四字符代码。它是一个32位uint_32的标示符，通过串联四个ASCII字符创建而成的，是一种独立标示视频数据流格式的四字符代码。每种YUV格式都指定了一个FOURCC码，它是视频播放软件通过查询FOURCC代码，并且寻找与FourCC代码相关联的视频解码器来播放特定的视频流。</p></blockquote><h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><h3 id="YUV概念"><a href="#YUV概念" class="headerlink" title="YUV概念"></a>YUV概念</h3><p><code>YUV</code>(亦称YCrCb)是指将亮度参量Y和色度参量U/V分开表示的像素格式，主要用于优化彩色视频信号的传输，使其向后兼容老式黑白电视。UV像素格式来源于RGB像素格式，通过公式运算，YUV三分量可以还原出RGB，YUV的三个分量具体含义如下：</p><ul><li><code>Y</code>表示亮度(灰度值)，通过将RGB信号的特定部分叠加到一起来创建。</li><li><code>U/Cr</code>表示色调，反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。</li><li><code>V/Cb</code>表示饱和度，反映的是RGB输入信号蓝色部分与RGB信号亮度值之同的差异。</li></ul><p>YUV将亮度信息<code>Y</code>与色彩信息<code>U/V</code>分离，没有<code>U/V</code>信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p><p><img src="../../assets/comm/yuv-y-u-v.gif" alt=""></p><h3 id="YUV采样"><a href="#YUV采样" class="headerlink" title="YUV采样"></a>YUV采样</h3><p>YUV码流的存储格式与其采样方式密切相关，主流的采样方式有三种：YUV4:4:4，YUV4:2:2，YUV4:2:0。</p><p>以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量，我们来看看这三种采样方式：</p><p><img src="../../assets/comm/yuv-sample.jpg" alt=""></p><p>其中：</p><ul><li>YUV 4:4:4采样，每一个Y对应一组UV分量。</li><li>YUV 4:2:2采样，每两个Y共用一组UV分量。</li><li>YUV 4:2:0采样，每四个Y共用一组UV分量。</li></ul><p>我们以八个临近像素为单位来分析下这三种主流的采样格式，假设四个像素的YUV分量分别如下：</p><script type="math/tex; mode=display">\begin{align*}[{Y}_{0}{U}_{0}{V}_{0}][{Y}_{1}{U}_{1}{V}_{1}][{Y}_{2}{U}_{2}{V}_{2}][{Y}_{3}{U}_{3}{V}_{3}] \\[{Y}_{4}{U}_{4}{V}_{4}][{Y}_{5}{U}_{5}{V}_{5}][{Y}_{6}{U}_{6}{V}_{6}][{Y}_{7}{U}_{7}{V}_{7}]\end{align*}</script><p>1、YUV 4:4:4</p><p><code>YUV 4:4:4</code>三个信道的抽样率相同，因此在生成的图像里，每个像素的三个分量信息完整(每个分量通常8比特)，经过8比特量化之后，未经压缩的每个像素占用3个字节。采样后八个像素的YUV分量如下：</p><script type="math/tex; mode=display">\begin{align*}[{Y}_{0}{U}_{0}{V}_{0}][{Y}_{1}{U}_{1}{V}_{1}][{Y}_{2}{U}_{2}{V}_{2}][{Y}_{3}{U}_{3}{V}_{3}] \\[{Y}_{4}{U}_{4}{V}_{4}][{Y}_{5}{U}_{5}{V}_{5}][{Y}_{6}{U}_{6}{V}_{6}][{Y}_{7}{U}_{7}{V}_{7}]\end{align*}</script><p>采样后，八个像素总共占用8Y+8U+8V=8×3=24个字节。</p><p>2、YUV 4:2:2</p><p><code>YUV 4:2:2</code>每个色差信道的抽样率是亮度信道的一半。对非压缩的8bit量化的图像来说，每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存。采样后八个像素的YUV分量如下：</p><script type="math/tex; mode=display">\begin{align*}[{Y}_{0}{U}_{0}{V}_{1}][{Y}_{1}{U}_{0}{V}_{1}][{Y}_{2}{U}_{2}{V}_{3}][{Y}_{3}{U}_{2}{V}_{3}] \\[{Y}_{4}{U}_{4}{V}_{5}][{Y}_{5}{U}_{4}{V}_{5}][{Y}_{6}{U}_{6}{V}_{7}][{Y}_{7}{U}_{6}{V}_{7}]\end{align*}</script><p>采样后，八个像素总共占用8Y+8×0.5U+8×0.5V=8×3*2/3=16个字节。</p><p>3、YUV 4:2:0</p><p><code>YUV 4:2:0</code>并不是说没有V分量，而是指对于每一个行，只有一个U或者V分量。相邻的扫描行存储不同的色度分量，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是4:2:0…以此类推。采样后八个像素的YUV分量如下：</p><script type="math/tex; mode=display">\begin{align*}[{Y}_{0}{U}_{0}{V}_{5}][{Y}_{1}{U}_{0}{V}_{5}][{Y}_{2}{U}_{2}{V}_{7}][{Y}_{3}{U}_{2}{V}_{7}] \\[{Y}_{4}{U}_{0}{V}_{5}][{Y}_{5}{U}_{0}{V}_{5}][{Y}_{6}{U}_{2}{V}_{7}][{Y}_{7}{U}_{2}{V}_{7}]\end{align*}</script><p>采样后，八个像素总共占用8Y+2U+2Y=8×3*2/4=12个字节。</p><h3 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h3><p>YUV存储格式有两大类：<code>打包(packed)格式</code>和<code>平面(planar)格式</code>。</p><ul><li>Planar YUV Formats：使用三个数组分开存放YUV三个分量，每个数组分别存储所有像素点的Y、U、V分量。</li><li>Packed YUV Formats：YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素(macro-pixel)，每个像素点的Y、U、V是连续交错存储的。</li></ul><p>根据上面的两种存储格式，可以形成很多种YUV存储方式。有关Packed YUV Formats和Planar YUV Formats列表可以参考<a href="http://www.fourcc.org/yuv.php">FOURCC YUV pixel formats</a>。</p><p>下面我们简要介绍下YUV422的几种存储格式：</p><p>1、UYVY Packed YUV Format</p><p><code>UYVY</code>是YUV 4:2:2采样方式的一种存储格式，其FOURCC码为<code>0x59565955</code>。水平方向上每两个像素作为一个宏像素，第一个像素采集YUV三个分量，第二个像素只采集Y分量。其存储格式如下：</p><script type="math/tex; mode=display">[{U}_{0}][{Y}_{0}][{V}_{0}][{Y}_{1}][{U}_{2}][{Y}_{2}][{V}_{2}][{Y}_{3}]{U}_{4}][{Y}_{5}][{V}_{4}][{Y}_{5}]</script><p>按照UYVY格式，每个宏像素32位，每个像素16位。</p><p>2、YV16 Planar YUV Formats</p><p><code>YV16</code>是YUV 4:2:2采样方式的一种存储格式，其FOURCC码为<code>0x36315659</code>。其存储为三个二维数组：</p><ul><li>Y数组</li></ul><script type="math/tex; mode=display">\begin{gather*}[{Y}_{0,0}][{Y}_{0,1}]...[{Y}_{0,m-1}]\\... \\[{Y}_{n-1,0}][{Y}_{n-1,1}]...[{Y}_{n-1,m-1}]\end{gather*}</script><ul><li>U数组</li></ul><script type="math/tex; mode=display">\begin{gather*}[{U}_{0,0}][{U}_{0,2}]...[{U}_{0,(m-1)/2}]\\... \\[{U}_{n-1,0}][{U}_{n-1,2}]...[{U}_{n-1,(m-1)/2}]\end{gather*}</script><p>3、YUV422 Sem-Planar YUV Format</p><p>这种格式混合了Packed和Planar两种格式，其存储为两个二维数组：</p><ul><li>Y数组</li></ul><script type="math/tex; mode=display">\begin{gather}[{Y}_{0,0}][{Y}_{0,1}]...[{Y}_{0,m-1}]\\... \\[{Y}_{n-1,0}][{Y}_{n-1,1}]...[{Y}_{n-1,m-1}]\end{gather}</script><ul><li>UV数组</li></ul><script type="math/tex; mode=display">\begin{gather*}[{U}_{0,0}][{V}_{0,0}][{U}_{0,2}][{V}_{0,2}]...[{U}_{0,(m-1)/2}][{V}_{0,(m-1)/2}]\\... \\[{U}_{n-1,0}][{V}_{n-1,0}][{U}_{n-1,2}][{V}_{n-1,2}]...[{U}_{n-1,(m-1)/2}][{V}_{n-1,(m-1)/2}]\end{gather*}</script><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB色彩空间通过三原色（R、G、B）来表示图像。常见的RGB格式包含RGB24、ARGB32等。</p><h3 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h3><p>RGB24是24位的颜色值，高八位为R、中间八位为G、低八位是B。</p><h3 id="ARGB32"><a href="#ARGB32" class="headerlink" title="ARGB32"></a>ARGB32</h3><p>ARGB32是32位的颜色值。高八位为A，次八位为R，再次八位为G，最后八位为B。</p><h2 id="YUV-RGB-in-Action"><a href="#YUV-RGB-in-Action" class="headerlink" title="YUV/RGB in Action"></a>YUV/RGB in Action</h2><p><a href="http://www.fourcc.org/fccyvrgb.php">FOURCC YUV to RGB Conversion</a>给出了YUV和RGB相互转换公式。同时，Windows开发人员也需要详细阅读[Video Rendering with 8-Bit YUV Formats](<a href="https://msdn.microsoft.com/zh-cn/library/aa904813：">https://msdn.microsoft.com/zh-cn/library/aa904813：</a></p><blockquote><p>本文讲述了在 Microsoft Windows 操作系统中呈现视频时推荐使用的 8 位 YUV 格式。本文讲述了可用于在 YUV 格式和 RGB 格式之间进行转换的技术，还提供了用于对 YUV 格式进行上采样的技术。本文适用于在 Windows 中使用 YUV 视频解码或呈现的所有人员。</p></blockquote><p>有关RGB/YUV视频像素数据的处理方法可以参考<a href="http://blog.csdn.net/leixiaohua1020/article/details/50534150">雷霄骅-视音频数据处理入门：RGB、YUV像素数据处理</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>1、<a href="http://www.fourcc.org/">FOURCC: Video Codecs and Pixel Format</a></li><li>2、<a href="https://msdn.microsoft.com/zh-cn/library/aa904813">Video Rendering with 8-Bit YUV Formats[原文]</a></li><li>3、<a href="https://msdn.microsoft.com/zh-cn/library/ms867704.aspx">使用8位YUV格式的视频呈现[译文]</a></li><li>4、<a href="http://blog.csdn.net/leixiaohua1020/article/details/50534150">视音频数据处理入门：RGB、YUV像素数据处理[雷霄骅]</a></li><li>5、<a href="https://wikipedia.freehacker.cn">FreeHacker’s Wikipedia</a></li></ul>]]></content>
    
    
    <summary type="html">简述YUV和RGB视频像素格式。</summary>
    
    
    <content src="http://ww4.sinaimg.cn/large/61b57e82gw1fb2cstahfqj20zi0bzaak.jpg" type="image"/>
    
    
    <category term="Developing" scheme="https://www.freehacker.cn/categories/Developing/"/>
    
    
    <category term="Media" scheme="https://www.freehacker.cn/tags/Media/"/>
    
    <category term="Codec" scheme="https://www.freehacker.cn/tags/Codec/"/>
    
  </entry>
  
  <entry>
    <title>如何设计C++类——《Effective C++》读后感</title>
    <link href="https://www.freehacker.cn/foundation/effective-cplusplus-reading/"/>
    <id>https://www.freehacker.cn/foundation/effective-cplusplus-reading/</id>
    <published>2017-03-13T16:02:00.000Z</published>
    <updated>2020-10-27T04:47:05.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>永远保持真诚，保持高尚的品行。把每天过成你的最后一天，活得充实、不留遗憾，有冒险精神、要英勇，但也要尽情享受，因为人生本短。<br>《神奇队长》</p></blockquote><p>一直以来，使用C++面向对象机制，主要是为了其封装和多态特性。往往设计类时，只是为了功能的堆砌，没有考虑的更加深入。</p><p>之前也阅读过《Effective C++》，只是那时是在学生时代。如今工作了，重新阅读，有不少新的感悟。最关键的是，能从更高的视角去设计程序，之前杂乱无序的点与点，逐渐连接成一条条线。希望后续能够成面、成立体。<a id="more"></a></p><p>回到正题：如何设计C++类？当然，更合理的表述应该是：如何设计高效、优雅的C++类？（菜鸟的思考）</p><blockquote><p>注意：我们并不是要设计一个程序，或者一个大的模块，我们考虑的更加具体，具体到其中的一点。</p></blockquote><h2 id="我们需要实现哪些功能？"><a href="#我们需要实现哪些功能？" class="headerlink" title="我们需要实现哪些功能？"></a>我们需要实现哪些功能？</h2><p>“先谋后动”，在设计具体类时，必须要清楚下面几点：</p><p>1、设计该类的目的</p><p>清晰的概念远比模棱两口的理解，更能帮助我们深入分析问题。有时候我们觉得我就是需要实现这个功能罢了，只要能用就好了。然而，多和产品经理或技术经理沟通，有可能出现意想不到的结果：</p><ul><li>该功能没有我们想到那么复杂，并不需要自己设计；</li><li>该功能比我们想到的更加复杂，我们需要考虑更多正确性、高效性、扩展性、维护性等方面的额问题。</li></ul><p>2、使用该类的场景</p><p>不同的使用场景，相同功能类的设计需求是不一样的。譬如，设计一个视频解码类，如果使用场景为视频播放器，那我们设计的类必须要考虑不同的编码格式；但如果使用场景为视频会议，我们设计的类就不需要考虑太多编码格式的问题，反而需要针对某种格式进行效率优化。</p><p>3、潜在的扩展方向</p><p>程序不是一成不变的，外界事物不停的变化，催生不同的需求。如果我们的程序不可扩展，那每次需求变更，之前的工作都白费了。类的设计一定要考虑到，未来潜在的扩展方向。如果我们无法确定潜在的扩展方向，至少留下可扩展的接口，不要把一切行为、属性都写死。</p><h2 id="如何构造析构、如何拷贝赋值？"><a href="#如何构造析构、如何拷贝赋值？" class="headerlink" title="如何构造析构、如何拷贝赋值？"></a>如何构造析构、如何拷贝赋值？</h2><p>C++类的构造析构和拷贝赋值是设计C++类时最基本的要点，有不少细节部分需要考虑：</p><ul><li>构造函数：合成的默认构造函数、默认构造函数、default关键词、explicit关键字、类型转换、延迟初始化、单例模式</li><li>析构函数：默认析构函数、虚析构函数</li><li>拷贝构造函数：深拷贝/浅拷贝、禁止拷贝</li><li>赋值构造函数：深拷贝/浅拷贝、禁止拷贝</li></ul><p>除了上面的细节部分，我们需要明确几个准则：</p><ul><li>除非默认操作非你所需，否则请用<code>=default</code>来定义构造析构函数；</li><li>除非编译器合成为你所需，否则请用<code>=delete</code>来定义赋值拷贝函数；</li><li>除非类不可能成为基类，否则请将析构函数定义为<code>virtual</code>；</li><li>构造与析构过程中，不调用virtual函数、析构函数不能抛出异常。</li><li>拷贝构造复制需要处理<code>深拷贝</code>和<code>浅拷贝</code>，赋值操作需要额外考虑<code>自我赋值</code>。</li></ul><h3 id="显式初始化和类型转换"><a href="#显式初始化和类型转换" class="headerlink" title="显式初始化和类型转换"></a>显式初始化和类型转换</h3><blockquote><p>首先表明我的立场：<strong>建议单参数构造函数都声明为explicit，拒绝隐式类型转换，除非你有意要隐式转换。</strong></p></blockquote><p>显式初始化主要针对于单参数构造函数，用<code>explicit</code>关键字来声明构造函数——拒绝隐式类型转换。在C++中，单参数的构造函数主要承担两个功能：对象构造、类型转换。</p><p>这儿强调<code>单参数</code>，是由于多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数声明为explicit，但你若是非要声明也是可以的。同时，我们只能在类内声明explicit关键词，不能再类外部重复声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">String::String</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; &#125; <span class="comment">/* error */</span></span><br><span class="line">String str = <span class="number">3</span>; <span class="comment">/* error */</span></span><br><span class="line"><span class="function">String <span class="title">str</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">/*  ok   */</span></span><br></pre></td></tr></table></figure><p>使用隐式类型转换需要注意的是<strong>编译器只会自动执行一步类型转换</strong>，从《C++ Primer》中摘取一个例子来看看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SalesData(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s);</span><br><span class="line">    <span class="function">SalesData&amp; <span class="title">combine</span><span class="params">(SalesData)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SalesData data;</span><br><span class="line">data.combine(<span class="string">&quot;99-99-99-99&quot;</span>); <span class="comment">/* error: cannot transfer &quot;99-99-99-99&quot; to std::string to SalesData at one time*/</span></span><br><span class="line">data.combine(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;99-99-99-99&quot;</span>)); <span class="comment">/* ok: transfer std::string to SalesData */</span></span><br></pre></td></tr></table></figure><p>很多时候，隐式的类型转换逻辑上是合理的，我们设计上需要实现一个隐式转换，是可以接受的。很多编译器会自动将类型转换操作转换成对象构造操作。譬如将整形转换成年龄：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Age(<span class="keyword">int</span> age);    </span><br><span class="line">&#125;;</span><br><span class="line">Age age = <span class="number">12</span>; <span class="comment">/* ok, same as Age age(12) */</span></span><br></pre></td></tr></table></figure><p>然而大多数隐式类型转换常常会带来逻辑上的错误，而且这种错误一旦发生很难查询，所以并不推荐使用隐式转换——<em>除非你是有意为之，否则都使用显式构造</em>。</p><blockquote><p><code>explicit</code>之所以被导入到C++，是为了提供程序员一种方法，使他们能够制止”单一参数的constructor”被当作一个conversion运算符。</p></blockquote><p>《C++ Primer》课后习题中有一题很好的阐述了——何时需要隐式转换、何时需要避免隐式转换：</p><blockquote><p>std::vector将其单参数构造函数定义成explicit的，而std::string则不是，你觉得原因何在？<br>std::string接受的单参数是const char*类型，如果我们得到了一个常量指针，则把它看做std::string对象是自然而然的过程，编译器自动把参数类型转换成类类型也非常符合逻辑，因此我们无须指定为explicit。与std::string相反，std::vector接受的单参数是int类型，这个参数的原意是指定std::vector的容量。如果我们在本来需要std::vector的地方提供一个int值并且希望这个int值自动转换成std::vector，则这个过程显得比较牵强，因此把std::vector的单参数构造函数定义成explicit的更加合理。</p></blockquote><p>C++的标准模板库是学习C++理论实践的好地方，总结下标准库中用explicit修饰的构造函数：</p><ul><li>接受一个容量参数的std::vector构造函数是explicit的。</li><li>接受一个指针参数的std::shared_ptr/std::auto_ptr构造函数是explicit的。</li><li>接受一个std::string参数的std::sstream构造函数是explicit的</li><li>接受一个std::string或C-String参数的std::fstream构造函数是explicit的</li></ul><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数表在构造函数中建立，在析构函数中销毁，因此构造函数不可能为虚函数，而析构函数可以为虚函数。同时，调用派生类构造函数，首先会出发基类的构造函数，如果基类的构造函数调用了一个虚函数，该虚函数此时并不具备多态特性。也就是——绝不要在构造和析构过程中调用虚函数。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>带有多态性质的基类应该声明一个virtual析构函数，如果class带有任何virtual函数，其就应该拥有一个virtual析构函数。默认情况下，类的析构函数是非虚函数，如果基类的析构函数是虚函数，则派生类的析构函数也都是虚函数。对于多态性质的基类，如果不声明虚析构函数，则会导致内存泄漏，看看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ball();</span><br><span class="line">    ~Ball()</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> _circle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasketBall</span> :</span> <span class="keyword">public</span> Ball &#123;</span><br><span class="line">&#125;</span><br><span class="line">Ball *ball = <span class="keyword">new</span> BasketBall();</span><br><span class="line"><span class="keyword">delete</span> ball; <span class="comment">/* 由于Ball的析构函数非虚，ball中属于Ball类部分的成员不会被析构 */</span></span><br></pre></td></tr></table></figure><p>当然，如果class一定不会用作基类使用，或者即使是作为基类使用，也不会定义virtual函数，那么是可以不用价格基类声明为virtual的。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>如果程序中某个类只允许有一个实例，这个时候就需要使用到单例模式。单例模式Wrapper有很多实现，譬如Boost中的singleton，Poco中的SingletonHold。我们来看看Poco中对单例Wrapper的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SingletonHolder():</span><br><span class="line">        _pS(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SingletonHolder()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _pS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">S* <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">FastMutex::ScopedLock <span class="title">lock</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!_pS) _pS = <span class="keyword">new</span> S;</span><br><span class="line">        <span class="keyword">return</span> _pS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    S* _pS;</span><br><span class="line">    FastMutex _m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看看Poco::SingletonHolder的代码，S类型的实例仅仅创建一次。如果我们需要将单例嵌入到自己的代码逻辑中，可以按照下面代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _s;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Release</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Release()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_s;</span><br><span class="line">    <span class="keyword">static</span> Release r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::_s = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton::Release Singleton::r;</span><br></pre></td></tr></table></figure><p>下文中延迟初始化那一节也是一种单例模式的实现。</p><h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><p>如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test() : p(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Test&quot;</span>)) &#123; &#125;</span><br><span class="line">    ~Test() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">    Test(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*t.p); <span class="comment">/* 如果这儿不进行深拷贝，析构时则会有多个对象重复删除p */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Test t) &#123;</span><br><span class="line">        swap(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *p;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="禁止拷贝"><a href="#禁止拷贝" class="headerlink" title="禁止拷贝"></a>禁止拷贝</h3><p>如果我们不需要编译器为我们实现默认拷贝构造函数，我们需要主动地驳回编译器这一默认的行为。通常的做法有三种：</p><ul><li>将相应的成员函数（这里是拷贝构造函数/赋值构造函数）声明为private，并不予实现；</li><li>将函数声明为delete；</li><li>继承一个不允许该操作的基类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnCopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    UnCopyable();</span><br><span class="line">    ~UnCopyable();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UnCopyable(<span class="keyword">const</span> UnCopyable&amp;);</span><br><span class="line">    UnCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UnCopyable&amp;)；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl</span> :</span> <span class="keyword">public</span> UnCopyable &#123; &#125;;</span><br></pre></td></tr></table></figure><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>延迟初始化是一个很有用的概念。一个对象的延迟初始化（也称延迟实例化）意味着该对象的创建将会延迟至第一次使用该对象时。延迟初始化主要用于提高性能，避免浪费计算，并减少程序内存要求。</p><blockquote><p><strong>尽量将对象的定义延迟到第一次使用，甚至是直到能够给它初值实参为止。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyInstance</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LazyInstance&amp; <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LazyInstance <span class="title">instance</span><span class="params">(param)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，instance实例对象直到getInstance()函数被第一次调用时，才会进行初始化。对比下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyInstance</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LazyInstance instance;</span><br></pre></td></tr></table></figure><p>instance实例对象是静态成员，会在程序一开始调用默认构造函数初始化。</p><p>延迟初始化同时也解决了<code>跨编译单元中非局部静态成员的初始化次序不定</code>的问题——函数内局部静态对象会在第一次调用时被初始化。我们通过下列例子来说明该问题（摘自Effective C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FileSystem.cpp */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directory.cpp */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(params);</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Director <span class="title">dir</span><span class="params">(tfs)</span></span>;</span><br></pre></td></tr></table></figure><p>由于FileSystem.cpp和Directory.cpp是两个编译单元，其初始化次序在C++标准中并没有被定义，我们无法确定tsf是否一定在dir初始化之前初始化。解决办法就是采用延迟初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>&#125;;</span><br><span class="line">Directory::Directory(params) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">dir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口设计需要考虑哪些问题？"><a href="#接口设计需要考虑哪些问题？" class="headerlink" title="接口设计需要考虑哪些问题？"></a>接口设计需要考虑哪些问题？</h2><p>接口设计的原则就是<code>易用</code>。为了达到<code>易用</code>的目的，我们需要遵循下面准则，同时也要考虑下面问题：</p><h3 id="接口一致准则"><a href="#接口一致准则" class="headerlink" title="接口一致准则"></a>接口一致准则</h3><blockquote><p>除非有好理由，否则应该尽量令你的类的行为与内置类型一致。</p></blockquote><p>接口的一致性，主要体现在两点：</p><ul><li>相同操作，自定义类型的行为应该与内置类型一致；</li><li>相同接口名，在同一自定义类型中，其功能、使用方式也应该一样；</li></ul><h3 id="误操作防御准则"><a href="#误操作防御准则" class="headerlink" title="误操作防御准则"></a>误操作防御准则</h3><p>考虑客户在使用该接口时，可能出现哪些错误，进行针对性防御设计。（如果防御编程消耗过大，就要仔细权衡了。）</p><ul><li>参数限定，譬如：<ul><li>如果参数存在上下限、固定值集合（月份值），最好进行限定（新建月份类型）；</li><li>如果是值传递，最好是改成常引用传递（内置类型、STL迭代器、函数对象除外）；</li><li>如果不想改变参数值，最好声明常参数。</li></ul></li><li>返回值限定，譬如：<ul><li>const限定（防止试图修改返回值）；</li><li>智能指针限定（防止内存泄漏）。</li></ul></li></ul><h3 id="私有还是公有？"><a href="#私有还是公有？" class="headerlink" title="私有还是公有？"></a>私有还是公有？</h3><p>为什么接口可以是私有呢？因为从广义来说，类的设计者也是类中成员的客户，私有的接口是面向类的设计者的。</p><p>对于成员函数，主要分为三种：私有、继承、公有，其安排主要是根据这三者的区别来定，没有什么特殊的地方。</p><p>对于数据成员，建议将所有数据成员声明为私有（考虑封装）。不管是类对象访问，还是派生类对象访问，都可以通过对应的getter/setter函数来操作。需要注意的是：protected并不比public更具封装性。</p><h3 id="成员函数还是非成员函数？"><a href="#成员函数还是非成员函数？" class="headerlink" title="成员函数还是非成员函数？"></a>成员函数还是非成员函数？</h3><ul><li><p>如果接口必须要操作类私有成员，需要将接口声明为成员函数或友元函数。</p></li><li><p>如果接口可以通过访问成员函数来进行所需操作，建议用<code>非成员、非友元函数</code>来替换成员函数。</p><p>因为这样做可以增加封装性、包括弹性和机能扩充性。这种<code>非成员、非友元函数</code>被称为便利函数，往往一个类会存在一系列不同的便利函数，功能相关的便利函数会被定义在同一个头文件内。</p></li><li><p>如果接口的所有参数都需要进行类型转换，那么这个函数必须是非成员函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational &amp;rhs) <span class="keyword">const</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rational oneEight(1, 8), oneHalf(1, 2);</span><br><span class="line">Rational result = oneHalf * oneEight; <span class="comment">/* ok */</span></span><br><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">/* ok */</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">/* error */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-member */</span></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure><h3 id="是否需要为inline函数？"><a href="#是否需要为inline函数？" class="headerlink" title="是否需要为inline函数？"></a>是否需要为inline函数？</h3><p>需要明确的是：inline只是对编译器的一个申请，并不是强制命令。将函数定义于class定义式内是隐喻inline的，定义于class定义式外需要显式声明为inline。通常inline函数被放置在头文件内。</p><p>如果编译器无法将你要求的函数inline化，其通常会给你一个警告信息。下列函数往往是非inline的：</p><ul><li>函数内部包含循环体；</li><li>构造函数/析构函数/虚函数；</li><li>存在被改变的可能：内联函数被改变，所有用到内联函数的程序都必须重新编译，而非内联函数只需要连接就行了。</li></ul><p>对于是否需要为inline函数的建议是：<em>将大多数inline函数限制在小型、被频繁调用的函数身上，同时不要因为函数模板出现在头文件，就将其声明为inline。</em></p><h3 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h3><p>接口与实现分离能够将编译依存性最小化，采用Handles Classes和Interface Classes能够很好地实现——相依于声明，不要相依于定义式。<strong>程序库头文件应该以完全且仅有声明式的形式存在，这种做法不论是否涉及template都适用。</strong></p><p>如果我们按照一般的C++教材上的方式现实代码，编译依存关系会导致很严重的重新编译和连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Person.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Data.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Data&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    Data        _birth;</span><br><span class="line">    Address     _addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码，如果Data.h中的内容或其依赖的内容有任何改变，所有包含Person.h头文件的源文件都需要重新编译和连接。</p><p>Handles Classes利用pimpl idiom（pointer to implementation）思想，利用该思想来重写上面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Person.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Data&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PersonImpl.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Data.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Data&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    Data        _birth;</span><br><span class="line">    Address     _addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person.cxx */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PersonImpl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Data&amp; birthday, <span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">    : pImpl(<span class="keyword">new</span> PersonImpl(name, birthday, addr)) &#123; &#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Person::name</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retur pImpl-&gt;name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interface Classes利用抽象基类和多态的特性，将接口定义在接口类中，而具体实现使用具体类，改写Person代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PersonI.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonI</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~PersonI();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonI&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Data &amp;birthday, <span class="keyword">const</span> Address &amp;addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PersonImpl.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PersonI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Data.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> :</span> <span class="keyword">public</span> PersonI &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Data&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">    Data        _birth;</span><br><span class="line">    Address     _addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PersonImpl.cxx */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PersonImpl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonI&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Data &amp;birthday, <span class="keyword">const</span> Address &amp;addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonI&gt;(<span class="keyword">new</span> PersonImpl(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种改写方法都存在一定的代价，一般程序库头文件推荐使用Interface Classes。</p></blockquote><h2 id="接口实现需要考虑哪些问题？"><a href="#接口实现需要考虑哪些问题？" class="headerlink" title="接口实现需要考虑哪些问题？"></a>接口实现需要考虑哪些问题？</h2><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>绝不要返回指向一个函数局部自动对象的指针或引用。</li><li>绝不要返回指向一个函数内部堆对象的引用，除非你能完全杜绝内存泄漏问题。</li><li>绝不要返回指向一个函数局部静态对象的指针或引用，如果有可能同时需要多个这样的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getStatic</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line">    test += param;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(getStatic(param1) == getStatic(param2)) &#123; ... &#125; <span class="comment">// 总是相等</span></span><br></pre></td></tr></table></figure><p>注意：第三种情况，并不是要我们完全不要返回，譬如我们需要某类型的唯一实例，返回函数局部静态变量是可行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person&amp; <span class="title">getPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免返回对象内部成分（私有成员：数据和函数）的句柄（指针或引用），例外：operator[]。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point&amp; <span class="title">getPoint</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _point; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point _point;</span><br><span class="line">&#125;;</span><br><span class="line">Point t;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Rect r;</span><br><span class="line">    t = r.getPoint();</span><br><span class="line">    t.setX(<span class="number">100</span>); <span class="comment">/* 我们更改了常对象内部的值 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = t.getX(); <span class="comment">/* r已被析构，t现在为空悬指针了，wops... */</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>优良的C++代码很少使用转型，但是也无法完全摆脱转型。考虑使用转型时，需要遵守下列准则：</p><ul><li>尝试使用无需转型操作的设计替代转型动作，譬如：使用类的多态特性取代dynamic_cast转型；</li><li>将转型操作隐藏在某个函数背后，如果需要转型时，调用该函数，而不是直接将转型操作放进代码内；</li><li>使用C++新式转型操作取代旧式转型操作。</li></ul><p>转型操作有时很难避免，因此我们需要清楚的掌握四种转型操作（static_cast、const_cast、reinterpret_cast、dynamic_cast）的差异与缺陷：</p><ul><li><code>dynamic_cast</code>：影响程序效率，同时也是程序异常的潜在因素，尽量拒绝使用dynamic_cast转型操作；</li><li><code>const_cast</code>：去除常量性，如果需要获取常量性，需要使用static_cast；</li><li><code>reinterpret_cast</code>：不可移植，在指针转换的时候可以使用，但是要慎用；</li><li><code>static_cast</code>：上面三种转型之外的转型操作都可以由static_cast来负责。</li></ul><blockquote><p>转型操作切记试图揣摩编译器中对象的布局，因为对象的布局是随着不同的编译器而不同的。</p></blockquote><h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3><p>通过良好的接口实现，<strong>接口使用者，无须考虑资源释放等问题</strong>。资源释放问题可以通过智能指针很好的解决。使用std::shared_ptr和删除器，我们能很好的解决资源释放问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Resource&gt; <span class="title">res</span><span class="params">(getResource(), releaseResource)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>当异常被抛出后，异常安全的函数不会泄露任何资源，也不允许数据败坏。异常安全函数能够提供下列三种保证之一：</p><ul><li>基本承诺：如果异常被抛出，程序内的任何事物都保持在有效状态下（并不保证是原来的状态）。</li><li>强烈保证：如果异常被抛出，如果函数成功，就会完全成功，如果函数失败，就会恢复到调用函数之前的状态。</li><li>不抛保证：绝不抛出异常，程序总能完成它们原先承诺的功能。</li></ul><blockquote><p>我们推荐：对于C++函数，需要提供强烈保证，尽量不抛保证。</p></blockquote><p>为了完成异常安全保证，我们需要知道哪些操作不抛异常，哪些操作会抛出异常，哪些操作有助于异常安全保证：</p><ul><li>作用于内置类型身上的所有操作都是nothrow保证的；</li><li>动态内存如果无法找到足够内存以满足需求会抛出bad_alloc异常；</li><li>swap函数提供不抛保证，利用<em>copy-and-swap</em>特性能够很轻松的完成强烈异常保证（当然也存在例外）；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; _image;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex _mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; _pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu::change</span><span class="params">(<span class="built_in">std</span>::istream&amp; src)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m</span><span class="params">(&amp;_mutex)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> PMImpl(*_pImpl);</span></span></span><br><span class="line"><span class="function"><span class="params">    p-&gt;_image.reset(<span class="keyword">new</span> Image(src));</span></span></span><br><span class="line"><span class="function"><span class="params">    ++p-&gt;imageChanges;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::swap(_pImpl, p);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>有时候我们是做不到强烈异常保证的，譬如消耗过大、程序结构复杂、历史代码等，这个时候就需要退而取其次——基本保证。函数提供的异常安全性保证通常最高只等于其所调用的各个函数的异常安全保证中的最弱者。所以，即使我们努力的保证了自己写的代码是强烈异常安全的，我们还是可能调用非此保证的代码。</p><blockquote><p>标准库版本的swap函数时不抛出异常的，如果我们需要自己实现swap函数，也务必要保证其不抛出异常——因为swap的一个最好的应用是帮助classes提供强烈的异常安全性保证。</p></blockquote><p>我们还需要注意一定：<strong>构造函数和析构函数一定不能抛出异常，否则会导致资源泄漏。</strong></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3>]]></content>
    
    
    <summary type="html">探讨如何设计高效的C++类，如何利用C++封装、继承、动态特性，实现高效、优雅、易于维护的代码。</summary>
    
    
    <content src="http://ww4.sinaimg.cn/large/61b57e82gw1f8obk6993nj21gs0i240q.jpg" type="image"/>
    
    
    <category term="Reading" scheme="https://www.freehacker.cn/categories/Reading/"/>
    
    
    <category term="CPlusPlus" scheme="https://www.freehacker.cn/tags/CPlusPlus/"/>
    
    <category term="OOP" scheme="https://www.freehacker.cn/tags/OOP/"/>
    
  </entry>
  
</feed>
